{
  "problem_type": "C转译Rust代码修复",
  "content": "## C转译Rust代码修复方法论\n\n### 问题重述\n当修复从C转译到Rust的代码时，需要确保Rust实现与原始C代码行为完全一致，同时处理Rust特有的约束（如借用检查器、panic vs exit等）。\n\n### 可复用解决流程\n\n#### 步骤1：功能一致性分析\n- 使用`read_code`读取原始C实现和当前Rust实现\n- 对比关键行为：边界条件、错误处理、返回值\n- 重点关注：空值处理、EOF标记、内存管理\n\n#### 步骤2：最小改动修复\n- 优先使用`edit_file`进行局部修改，避免重构\n- 修改前记录原始代码（通过git diff或临时文件）\n- 确保Rust特有约束（借用检查器）的兼容性\n\n#### 步骤3：测试验证策略\n- 运行`cargo test`验证基本功能\n- 对于会exit的C函数：改为文档化测试或跳过测试\n- 对于panic行为：使用`#[should_panic]`但要考虑exit vs panic差异\n- 检查回归测试：确保修复不破坏原有测试\n\n#### 步骤4：边界条件验证\n- 空参数/空输入\n- 边界值（0、最大值）\n- 错误路径（EOF、无效输入）\n\n### 注意事项\n- C的exit()与Rust的panic!()行为不同，测试中需要特殊处理\n- Rust借用检查器可能导致需要调整变量作用域\n- 链表操作要注意所有权转移问题\n- 保持与C代码的内存行为一致（如何时分配、何时释放）\n\n### 可选步骤\n- 添加更多边界条件测试\n- 性能基准测试（如需要）\n- 内存使用验证"
}