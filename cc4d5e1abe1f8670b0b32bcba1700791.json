{
  "problem_type": "验证C移植到Rust的行为一致性",
  "content": "# C移植到Rust行为一致性验证方法论\n\n## 问题重述\n在将C代码移植到Rust时，确保行为一致性是一个关键挑战。特别是涉及指针操作、边界处理和返回值逻辑时，需要系统化的验证方法。\n\n## 可复用解决流程\n\n### 步骤1：获取C源码行为基准\n1. 使用execute_script工具搜索相关C源码：\n   ```bash\n   find . -name \\\"*.c\\\" -o -name \\\"*.h\\\" | xargs grep -l \\\"函数名\\\"\n   ```\n2. 使用grep提取关键行为：\n   ```bash\n   grep -A 10 -B 5 \\\"函数名\\\" 文件名\n   ```\n\n### 步骤2：分析关键差异点\n1. 指针操作 vs 迭代器行为\n   - C: `*rest = p + 1`（指针偏移）\n   - Rust: 需要返回`iter.next()`而不是当前元素\n2. 边界条件处理\n   - 检查EOF和错误处理逻辑\n   - 验证空输入情况\n\n### 步骤3：验证返回值逻辑\n1. 使用read_code工具检查Rust实现的关键返回点\n2. 对比C实现的行为模式\n3. 确认是否返回终止位置之后的元素\n\n### 步骤4：运行测试验证\n1. 使用cargo test运行相关测试：\n   ```bash\n   cargo test 函数名\n   ```\n2. 如果没有专门测试，运行完整测试套件：\n   ```bash\n   cargo test\n   ```\n\n### 步骤5：创建行为一致性测试\n1. 针对关键差异点创建测试用例\n2. 创建边界条件测试\n3. 验证空输入和错误情况\n\n## 注意事项\n- C中的指针偏移+1在Rust中通常对应迭代器的next()\n- 需要特别注意边界条件和空输入的处理\n- Rust的迭代器可能需要在返回前额外调用一次next()\n\n## 可选步骤\n- 创建自动化脚本对比C和Rust的行为\n- 使用模糊测试验证边界情况\n- 添加性能测试确保移植后性能相当"
}