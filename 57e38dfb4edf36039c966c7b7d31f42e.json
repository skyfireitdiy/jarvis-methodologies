{
  "problem_type": "批量重构",
  "content": "# 批量重构方法论\n\n## 规则简介\n\n本方法论提供了系统化处理多项目批量重构任务的指导原则和执行流程。适用于需要对多个相似项目进行相同改造的场景（如添加统一配置、升级依赖、修改架构等）。通过项目分类、分批处理和持续验证，确保批量重构的高效性和可靠性。\n\n## 你必须遵守的原则\n\n### 原则1：分类优先原则\n\n**要求说明：**\n\n- **必须**：在开始重构前，先对项目进行系统化分类\n- **必须**：根据项目当前状态、改造复杂度、依赖关系等多维度分类\n- **禁止**：不经过分析就直接对所有项目进行相同处理\n\n**分类维度：**\n\n1. **按当前状态分类**：已有配置 vs 需要添加配置\n2. **按改造复杂度分类**：简单改造 vs 复杂改造（需要额外配置）\n3. **按依赖关系分类**：独立项目 vs 有依赖的项目\n4. **按风险等级分类**：低风险 vs 高风险（核心模块、生产环境）\n\n### 原则2：分批处理原则\n\n**要求说明：**\n\n- **必须**：使用任务列表管理工具分批处理，避免一次性处理所有项目\n- **必须**：每批处理3-8个项目，确保每批能够在合理时间内完成\n- **必须**：同批项目应具有相似的改造复杂度和风险等级\n- **禁止**：一次性处理所有项目，难以跟踪进度和问题\n\n**分批策略：**\n\n- **第1批**：高风险项目，验证重构方案可行性\n- **第2批**：中风险项目，验证方案普适性\n- **第3批**：低风险项目，大批量处理\n- **第4批**：剩余项目，处理特殊情况\n\n### 原则3：持续验证原则\n\n**要求说明：**\n\n- **必须**：每批改造完成后立即验证，发现问题及时调整\n- **必须**：使用快速验证方法，减少验证时间（如使用 `-p` 参数）\n- **必须**：记录每批的执行结果和遇到的问题\n- **禁止**：所有项目改造完成后再统一验证\n\n**验证标准：**\n\n1. 编译验证：确保代码能正常编译\n2. 功能验证：确保核心功能不受影响\n3. 配置验证：确保配置符合规范要求\n\n### 原则4：最小改动原则\n\n**要求说明：**\n\n- **必须**：只修改必要的配置和代码，避免不必要的变更\n- **必须**：保持现有功能和配置，不删除已有设置\n- **必须**：使用精确的 search/replace，避免误改\n- **禁止**：大范围重构或删除现有代码\n\n## 你必须执行的操作\n\n### 阶段1：项目分析\n\n1. **批量查看项目结构**\n   - 使用 execute_script 批量查看项目目录结构\n   - 识别需要改造的项目清单\n   - 排除非项目文件（如文档、测试数据等）\n\n2. **批量读取配置文件**\n   - 使用 execute_script 批量读取 Cargo.toml、package.json 等配置文件\n   - 识别项目当前状态和配置差异\n   - 记录已有的依赖、features、配置项\n\n3. **分析源码依赖**\n   - 读取关键源码文件（如 main.rs、index.js）\n   - 识别使用的模块、函数、类\n   - 判断需要的依赖和配置\n\n4. **项目分类**\n   - 根据分析结果对项目进行分类\n   - 标注每类的改造复杂度和风险等级\n   - 制定分批处理计划\n\n### 阶段2：方案设计\n\n1. **设计改造方案**\n   - 为每类项目设计对应的改造方案\n   - 明确需要修改的文件和内容\n   - 定义验证标准和方法\n\n2. **参考示例项目**\n   - 查找已有的成功改造示例\n   - 分析示例项目的配置和代码\n   - 总结最佳实践\n\n3. **制定分批计划**\n   - 按分类结果和复杂度分批\n   - 每批包含相似的项目\n   - 估算每批的执行时间\n\n4. **准备验证方法**\n   - 设计快速验证方法（如使用 `-p` 参数）\n   - 准备测试用例和验证脚本\n   - 定义验收标准\n\n### 阶段3：批量执行\n\n1. **创建任务列表**\n   - 使用 task_list_manager 创建任务列表\n   - 为每批任务定义清晰的描述和预期输出\n   - 设置任务依赖关系\n\n2. **分批执行改造**\n   - 按顺序执行每批任务\n   - 每批完成后立即验证\n   - 记录执行结果和问题\n\n3. **处理异常情况**\n   - 遇到问题立即停止当前批次\n   - 分析问题原因，调整改造方案\n   - 修改受影响的项目配置\n\n4. **持续优化方案**\n   - 根据每批的执行结果优化后续批次\n   - 调整改造方案和验证方法\n   - 更新最佳实践文档\n\n### 阶段4：验收总结\n\n1. **整体验证**\n   - 验证所有项目的改造结果\n   - 运行集成测试和端到端测试\n   - 确保所有项目符合验收标准\n\n2. **总结经验**\n   - 记录改造过程中的关键发现\n   - 总结最佳实践和常见问题\n   - 更新相关文档和规则\n\n3. **保存记忆**\n   - 使用 save_memory 保存关键信息\n   - 保存项目长期记忆（配置、架构决策）\n   - 保存全局长期记忆（最佳实践、方法论）\n\n## 实践指导\n\n### 最佳实践\n\n1. **使用脚本批量操作**\n   - 使用 execute_script 批量查看和读取文件\n   - 使用 rg、fd 等工具快速定位文件\n   - 避免手动逐个处理\n\n2. **优化验证时间**\n   - Rust项目使用 `-p` 参数只编译目标包\n   - 其他项目使用增量构建或并行测试\n   - 避免全量编译和测试\n\n3. **保持配置一致性**\n   - 同类项目使用相同的配置模式\n   - 遵循项目规范和最佳实践\n   - 保持代码风格一致\n\n4. **及时记录问题**\n   - 记录每个批次的执行结果\n   - 记录遇到的问题和解决方案\n   - 为后续批次提供参考\n\n### 常见错误\n\n1. **错误1：未分类直接批量处理**\n   - **问题**：不同复杂度的项目混在一起，难以跟踪\n   - **解决**：先分类，再分批处理\n\n2. **错误2：验证不充分**\n   - **问题**：所有项目改造完成后再验证，发现问题难以定位\n   - **解决**：每批完成后立即验证\n\n3. **错误3：过度改造**\n   - **问题**：修改了不必要的配置和代码\n   - **解决**：遵循最小改动原则\n\n4. **错误4：忽略现有配置**\n   - **问题**：删除了已有的配置项，导致功能失效\n   - **解决**：保持现有配置，只添加必要内容\n\n### 注意事项\n\n1. **使用版本控制**\n   - 确保项目在版本控制系统下\n   - 每批次完成后提交代码\n   - 便于回退和追踪\n\n2. **备份重要文件**\n   - 改造前备份关键配置文件\n   - 保留原始文件副本\n   - 确保可以快速回退\n\n3. **与团队沟通**\n   - 提前通知团队成员批量改造计划\n   - 说明改造的范围和影响\n   - 避免团队成员的工作被覆盖\n\n4. **预留足够时间**\n   - 批量重构通常比预期耗时\n   - 预留处理问题的时间\n   - 避免仓促完成\n\n## 检查清单\n\n在完成批量重构后，你需要确认：\n\n- [ ] 所有项目已按分类完成改造\n- [ ] 每批项目均已通过验证\n- [ ] 配置符合项目规范和最佳实践\n- [ ] 代码编译无错误和警告\n- [ ] 核心功能测试通过\n- [ ] 关键信息已保存到长期记忆\n- [ ] 文档已更新（README、CHANGELOG等）\n- [ ] 临时文件已清理\n- [ ] 代码已提交到版本控制系统\n- [ ] 团队已通知改造完成\n\n## 适用场景\n\n**适用的重构类型：**\n\n- 添加统一的配置或依赖\n- 升级项目依赖版本\n- 修改项目架构或目录结构\n- 统一代码风格或规范\n- 添加新的构建或测试流程\n- 迁移到新的工具或框架\n\n**不适用的场景：**\n\n- 需要个性化改造的项目（差异过大）\n- 极高风险的项目（生产核心系统）\n- 不确定重构方案的场景（需要先试点）\n- 项目数量过少（1-2个项目）\n\n## 示例：Rust项目批量添加双模式构建支持\n\n**项目分类：**\n\n1. 按依赖状态：已有idf依赖 vs 需要添加idf依赖\n2. 按features复杂度：基础配置 vs 需要额外features（comm_pubsub、hotpatch_so）\n3. 按库依赖：仅idf vs 需要额外库链接\n\n**分批处理：**\n\n- 第1批：timer_benchmark + 4个已有依赖的项目（5个）\n- 第2批：3个已有依赖的项目（3个）\n- 第3批：8个需要添加依赖的项目（8个）\n\n**验证优化：**\n\n使用 `cargo build --release -p <package_name>` 只编译目标包，避免全量编译",
  "scope": "global"
}