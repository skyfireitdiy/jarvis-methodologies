{
  "problem_type": "Rust作用域测试调试方法",
  "content": "## Rust作用域测试调试方法论\n\n### 问题重述\n在多层作用域环境中，find_tag函数无法正确找到内层作用域的标签，测试用例失败。\n\n### 可复用解决流程\n\n**步骤1：状态诊断**\n- 运行特定模块测试：`cargo test sema::scope -- --nocapture`\n- 识别失败用例：test_find_tag_found, test_find_tag_nested_scopes\n- 检查全局状态污染情况\n\n**步骤2：作用域查找验证**\n- 确认查找顺序：检查find_tag函数中的遍历逻辑\n- 验证遍历方向：`scopes.iter().rev()`应实现从内到外\n- 添加调试输出：在遍历过程中打印作用域层级和查找结果\n\n**步骤3：测试隔离检查**\n- 验证清理函数：clear_scopes()和clear_typedefs()在每个测试中的调用\n- 检查状态重置：确保测试开始前SCOPES和TYPEDEF_MAP被重置\n- 验证默认作用域：测试后应有至少一个默认作用域\n\n**步骤4：调试输出添加**\n```rust\npub fn find_tag(token: &Token) -> Option<&Type> {\n    let name = &token.text;\n    let scopes = SCOPES.lock().unwrap();\n   \n    // 调试输出：当前作用域数量\n    println!(\"DEBUG: 查找标签 '{}'，当前作用域数量: {}\", name, scopes.len());\n   \n    for (i, scope) in scopes.iter().rev().enumerate() {\n        println!(\"DEBUG: 检查作用域 {} (索引: {})\", i, scopes.len() - 1 - i);\n        if let Some(ty) = scope.tags.get(name) {\n            println!(\"DEBUG: 在作用域 {} 找到标签\", i);\n            return Some(*ty);\n}\n}\n   \n    println!(\"DEBUG: 未在任何作用域找到标签 '{}'\", name);\n    None\n}\n```\n\n### 注意事项\n- 调试输出仅在测试模式下使用#[cfg(test)]\n- 全局状态清理必须在每个测试的setUp/tearDown中执行\n- 作用域索引计算：rev()遍历时下标与原始顺序相反\n\n### 可选步骤\n- 使用cargo test --test-threads=1避免并发测试问题\n- 添加作用域状态验证辅助函数\n- 实现作用域树的可视化调试工具"
}