{
  "problem_type": "Rust并发测试状态污染诊断",
  "content": "# Rust并发测试状态污染诊断方法论\n\n## 问题重述\nRust测试在单独运行时通过，但在完整测试套件运行时失败，通常是由于全局状态污染导致的并发安全问题。\n\n## 可复用解决流程\n\n### 步骤1：问题复现与模式识别\n- **工具**：cargo test\n- **命令**：  \n   ```\n  # 验证单线程通过性\n  cargo test [测试模块] -- --test-threads=1\n \n  # 验证多线程失败\n  cargo test [测试模块]\n   ```\n- **预期结果**：单线程通过，多线程失败\n\n### 步骤2：全局状态识别\n- **检查目标**：\n  - `static`变量和`once_cell::sync::Lazy`声明\n  - `std::sync::Mutex`和锁的使用\n  - 全局HashMap、Vec等可变集合\n- **工具**：rg 'static|Lazy|Mutex' src/\n\n### 步骤3：状态重置验证\n- **检查函数**：clear_*、reset_*、cleanup_*等重置函数\n- **验证逻辑**：确保重置函数能完全恢复初始状态\n- **测试方法**：在每个测试用例前后添加重置调用\n\n### 步骤4：并发安全分析\n- **检查Mutex**：验证是否有PoisonError处理\n- **检查竞争条件**：分析多线程对全局状态的访问模式\n- **验证原子性**：确保状态操作的原子性\n\n### 步骤5：解决方案实施\n1. **短期方案**：添加测试锁串行化\n   ```rust\n   static TEST_LOCK: Mutex<()> = Mutex::new(());\n  \n   #[test]\n   fn test_example() {\n       let _guard = TEST_LOCK.lock().unwrap();\n       // 测试代码\n   }\n   ```\n2. **长期方案**：重构设计避免全局状态\n\n### 注意事项\n- Mutex::lock()可能返回PoisonError，需要适当处理\n- 考虑使用thread_local!替代全局状态\n- 测试用例间保持完全独立\n\n### 可选步骤\n- 使用cargo-nextest获得更好的测试隔离\n- 实现自定义的测试框架支持状态管理\n- 使用条件编译为测试提供特殊实现"
}