{
  "problem_type": "Rust全局状态测试污染诊断",
  "content": "## Rust全局状态测试污染诊断方法论\n\n### 问题重述\n在Rust项目中，当测试在单独运行时通过，但在完整测试套件中失败时，通常是由于全局静态变量状态污染导致的测试间相互影响。\n\n### 可复用解决流程\n\n#### 步骤1: 验证测试行为差异\n```bash\n# 单独运行测试\ncargo test 模块::tests::具体测试名 -- --exact --nocapture\n\n# 完整套件运行（默认多线程）\ncargo test\n\n# 单线程运行验证\ncargo test -- --test-threads=1\n```\n\n#### 步骤2: 识别全局状态污染源\n1. 搜索项目中的全局静态变量：`rg \"static.*:\" src/`\n2. 重点关注使用以下类型的变量：\n   - `static mut`\n   - `once_cell::sync::Lazy`\n   - `std::sync::Mutex`\n   - 全局集合类型（Vec, HashMap等）\n\n#### 步骤3: 分析状态管理实现\n检查每个全局变量是否有：\n1. 状态重置机制（reset/clear函数）\n2. 正确的锁处理（处理Mutex poisoned错误）\n3. 完整的资源清理（文件删除、内存释放）\n\n#### 步骤4: 添加诊断信息\n在关键位置添加调试输出：\n```rust\neprintln!(\"DEBUG: 变量状态: {:?}\", guard);\neprintln!(\"DEBUG: 清理后状态: {:?}\", guard);\n```\n\n#### 步骤5: 验证修复方案\n1. 实现reset函数确保完全清理\n2. 在每个测试前后调用reset\n3. 使用测试夹具自动管理\n\n### 工具使用\n- `execute_script`：运行不同模式的测试\n- `read_code`：分析全局变量和reset实现\n- `retrieve_memory`：获取历史类似问题的解决方案\n\n### 注意事项\n- 单线程通过但多线程失败 ⇒ 状态管理问题\n- 所有模式都失败 ⇒ 逻辑实现问题\n- 必须验证reset函数真正清理了所有状态\n- 考虑使用测试fixture模式自动管理状态\n\n### 可选步骤\n对于复杂场景，可以创建专门的测试工具：\n```rust\n#[cfg(test)]\npub struct TestGuard {\n    // 自动清理全局状态\n}\n\nimpl Drop for TestGuard {\n    fn drop(&mut self) {\n        reset_all_global_state();\n}\n}\n```"
}