{
  "problem_type": "Rust原子操作边界值测试",
  "content": "问题重述：在测试Rust原子操作（如fetch_add/fetch_sub）的边界值行为时，需要验证wrapping语义是否正确处理溢出情况。\n\n可复用解决流程：\n1. **边界值识别**\n   - 识别关键边界：0、usize::MAX、usize::MAX-1\n   - 确定测试场景：递增溢出、递减下溢\n\n2. **测试用例设计**\n   - 设计测试：从usize::MAX+1应该wrapping到0\n   - 设计测试：从0-1应该wrapping到usize::MAX\n   - 验证fetch_add/fetch_sub的返回值语义\n\n3. **测试实现方法**\n   - 使用reset函数确保测试间状态隔离\n   - 使用AtomicUsize::store设置初始边界值\n   - 验证old.wrapping_add(1)或old.wrapping_sub(1)的返回值\n   - 使用assert_eq!验证最终状态\n\n4. **验证工具组合**\n   - 使用execute_script运行特定边界测试\n   - 使用cargo test -- --nocapture查看详细输出\n   - 使用cargo test -- --test-threads=1避免并发干扰\n\n注意事项：\n- 原子操作返回旧值，需要使用wrapping运算计算新值\n- 边界测试必须包含极端值验证\n- 确保测试reset函数正确清除全局状态\n- 考虑使用proptest进行属性测试\n\n示例测试模式：\n```rust\n#[test]\nfn test_boundary_overflow() {\n    reset_state();\n    COUNTER.store(usize::MAX, Ordering::Relaxed);\n    let old = COUNTER.fetch_add(1, Ordering::Relaxed);\n    assert_eq!(old.wrapping_add(1), 0);\n    assert_eq!(COUNTER.load(Ordering::Relaxed), 0);\n}\n```"
}