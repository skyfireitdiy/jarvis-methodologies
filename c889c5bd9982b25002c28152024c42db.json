{
  "problem_type": "C代码移植到Rust实现",
  "content": "# C代码移植到Rust实现方法论\n\n## 问题重述\n将现有的C语言代码（特别是编译器/解析器相关代码）移植到Rust，需要保持功能一致性，同时符合Rust的所有权和借用规则。\n\n## 可复用解决流程\n\n### 阶段1：需求分析与准备\n1. **定位C源码**：使用`read_code`读取关键C文件，标记需要移植的函数范围\n2. **识别项目结构**：使用`lsp_client`搜索符号，了解现有Rust代码结构\n3. **移除重复定义**：检查并消除重复的结构体/类型定义（如File结构体）\n\n### 阶段2：核心实现\n1. **分析C函数逻辑**：\n   - 逐行分析C代码逻辑\n   - 识别内存管理模式（malloc/free → Rust所有权）\n   - 标记指针使用场景\n\n2. **设计Rust接口**：\n   - 将C的返回值错误码 → Rust的Result类型\n   - 将C的全局变量 → Rust的结构体字段\n   - 将C的字符串处理 → Rust的&str/String\n\n3. **实现核心函数**：\n   - 使用`rewrite_file`或`edit_file`逐步替换实现\n   - 保持函数签名与C版本语义一致\n   - 添加中文注释说明关键逻辑\n\n### 阶段3：测试验证\n1. **创建测试用例**：\n   - 使用`create_test_file`创建测试输入\n   - 设计覆盖各种边界情况的测试\n   - 包含空输入、特殊字符、边界值测试\n\n2. **执行测试**：\n   - 运行`cargo test`验证所有测试通过\n   - 使用`execute_script`清理测试产生的临时文件\n\n3. **代码审查**：\n   - 检查是否有未使用的变量或函数\n   - 验证所有警告已修复\n   - 确认代码风格一致性\n\n## 注意事项\n- **内存安全**：特别注意C中的裸指针转换为Rust的引用或Box\n- **错误处理**：将C的错误码转换为Rust的Result和Error类型\n- **性能考虑**：Rust的字符串处理可能比C慢，必要时使用字节切片\n- **兼容性**：确保UTF-8/UTF-16/UTF-32字符处理的正确性\n\n## 可选步骤\n- **性能优化**：使用`cargo bench`进行性能测试\n- **扩展测试**：增加fuzzing测试验证鲁棒性\n- **文档完善**：为公共API添加Rust文档注释"
}