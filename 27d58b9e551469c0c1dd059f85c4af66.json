{
  "problem_type": "代码版本内存对比测试",
  "content": "# 代码版本内存对比测试\n\n## 规则简介\n\n本方法论用于对比不同代码版本之间的内存使用差异，通过控制变量法（仅修改关键代码）来验证优化效果。适用于：\n- 验证内存优化方案的有效性\n- 对比不同实现的内存占用\n- 定位内存泄漏或增长原因\n\n## 你必须遵守的原则\n\n### 版本隔离原则\n\n**要求说明：**\n\n- **必须**：每次测试前确认代码版本（git commit 或 git diff）\n- **必须**：测试完成后恢复原始版本（git restore 或 git checkout）\n- **必须**：备份当前版本代码，确保可以回退\n- **禁止**：在生产环境进行未经验证的测试\n\n### 数据一致性原则\n\n**要求说明：**\n\n- **必须**：使用相同的编译配置和运行环境\n- **必须**：采集相同的内存指标（status 和 smaps）\n- **必须**：等待程序稳定后再采集（sleep 3-5秒）\n- **禁止**：在程序启动瞬间采集内存数据\n\n### PID 正确性原则\n\n**要求说明：**\n\n- **必须**：使用 pgrep 或 ps 确认进程真实 PID\n- **禁止**：依赖后台运行的 $! 变量（会获取到 shell PID）\n- **禁止**：假设进程名唯一，需验证进程信息\n\n## 你必须执行的操作\n\n### 阶段1：代码版本准备\n\n1. **确认当前版本**：\n   ```bash\n   git log --oneline | head -5\n   git diff HEAD\n   ```\n\n2. **备份当前版本**（可选但推荐）：\n   ```bash\n   cp path/to/source.rs path/to/source.rs.backup\n   ```\n\n3. **切换到目标版本**：\n   - 方式A：回退到指定提交\n   ```bash\n     git checkout <commit-hash>^ -- path/to/file.rs\n   ```\n   - 方式B：手动修改代码\n\n4. **验证代码改动**：\n   ```bash\n   git diff path/to/source.rs\n   ```\n\n### 阶段2：编译和运行\n\n1. **清理旧版本**：\n   ```bash\n   cargo clean  # 可选，确保完全重新编译\n   ```\n\n2. **编译目标版本**：\n   ```bash\n   cargo build --release --bin <target_name>\n   ```\n\n3. **配置运行环境**：\n   - 设置 LD_LIBRARY_PATH（如需依赖库）\n   - 准备配置文件和数据\n\n4. **运行程序并采集内存**：\n   ```bash\n   # 启动程序\n   <executable> > /tmp/run.log 2>&1 &\n  \n   # 等待程序稳定\n   sleep 3-5\n  \n   # 获取真实 PID（关键步骤）\n   PID=$(pgrep -f '<executable_name>$' | head -1)\n  \n   # 验证 PID 正确性\n   ps -p $PID -o pid,comm,vsz,rss\n  \n   # 采集内存信息\n   cat /proc/$PID/status > /tmp/version_<name>_status.txt\n   cat /proc/$PID/smaps > /tmp/version_<name>_smaps.txt\n  \n   # 清理进程\n   kill $PID\n   ```\n\n### 阶段3：数据验证和对比\n\n1. **验证数据完整性**：\n   ```bash\n   # 检查文件大小\n   ls -lh /tmp/version_*.txt\n  \n   # 验证进程名称正确\n   head -5 /tmp/version_<name>_status.txt\n   ```\n\n2. **提取关键指标**：\n   ```bash\n   # VmRSS（物理内存）\n   grep VmRSS /tmp/version_*_status.txt\n  \n   # RssAnon（匿名内存）\n   grep RssAnon /tmp/version_*_status.txt\n  \n   # Private_Dirty（私有脏页）\n   grep Private_Dirty /tmp/version_*_smaps.txt | awk '{sum+=$2} END {print sum}'\n   ```\n\n3. **计算差异**：\n   - 对比各版本的 VmRSS、RssAnon、Private_Dirty\n   - 计算内存增减百分比\n   - 识别内存映射段数量变化\n\n### 阶段4：恢复和清理\n\n1. **恢复代码版本**：\n   ```bash\n   git restore path/to/source.rs\n   # 或\n   git checkout HEAD -- path/to/source.rs\n   rm -f path/to/source.rs.backup\n   ```\n\n2. **验证恢复结果**：\n   ```bash\n   git status\n   grep '关键代码' path/to/source.rs\n   ```\n\n3. **清理临时文件**：\n   ```bash\n   # 清理编译产物（如需）\n   # rm -f /tmp/run.log\n   ```\n\n## 实践指导\n\n### 常见问题和解决方案\n\n**问题1：PID 获取错误**\n- 现象：采集到的是 shell 或其他进程的内存信息\n- 原因：后台运行时 $! 获取的是 shell 的 PID\n- 解决：使用 `pgrep -f '<程序名>$'` 并验证 `ps -p $PID`\n\n**问题2：共享库依赖缺失**\n- 现象：error while loading shared libraries\n- 解决：使用 `ldd <executable>` 检查依赖，配置 LD_LIBRARY_PATH\n\n**问题3：程序启动即退出**\n- 原因：缺少配置文件、环境变量或运行时参数\n- 解决：检查程序日志，提供必要的配置（如 configure.json）\n\n**问题4：内存数据不稳定**\n- 原因：程序刚启动，内存尚未稳定\n- 解决：增加等待时间（sleep 5-10），或在程序稳定运行时采集\n\n### 数据分析要点\n\n1. **关注核心指标**：\n   - VmRSS：实际占用的物理内存\n   - RssAnon：匿名内存（堆、栈等）\n   - Private_Dirty：进程独占的脏页（真正的内存成本）\n\n2. **识别内存泄漏**：\n   - 对比多次运行的内存数据\n   - 检查堆内存段（heap）是否持续增长\n   - 分析匿名映射（anonymous）的数量和大小\n\n3. **对比内存布局**：\n   - smaps 中的内存映射段数量\n   - 最大内存段的大小\n   - 共享库和匿名映射的比例\n\n## 检查清单\n\n测试前准备：\n\n- [ ] 确认当前代码版本（git log）\n- [ ] 备份关键源文件\n- [ ] 准备测试环境和依赖库\n- [ ] 确认数据保存路径\n\n数据采集：\n\n- [ ] 编译成功且无警告\n- [ ] 程序正常运行（ps 验证）\n- [ ] PID 正确（pgrep + ps 验证）\n- [ ] status 和 smaps 文件完整（检查大小）\n- [ ] 进程名称正确（查看 Name 字段）\n\n数据验证：\n\n- [ ] 文件大小合理（status ~1KB, smaps ~50-200KB）\n- [ ] 内存指标在预期范围\n- [ ] 数据可读、无乱码\n\n恢复清理：\n\n- [ ] 代码已恢复到原始版本\n- [ ] git status 显示无未提交修改\n- [ ] 临时文件已清理\n- [ ] 编译产物保留（如需后续测试）",
  "scope": "global"
}