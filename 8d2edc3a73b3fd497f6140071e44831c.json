{
  "problem_type": "C++ new操作内存安全问题修复",
  "content": "## 问题重述\n修复C++代码中new操作未处理内存分配失败的安全问题，避免空指针解引用导致的程序崩溃。\n\n## 可复用解决流程\n\n### 步骤1：识别问题位置\n```bash\n# 查找所有new操作\nrg -n 'new [^(]' *.cpp *.cc *.cxx\n\n# 查找已有的空指针检查\nrg -n 'if.*== nullptr' *.cpp\n```\n\n### 步骤2：实施修复\n1. **添加头文件**：在文件顶部添加 `#include <new>`\n2. **修改new操作**：将 `new T(...)` 改为 `new (std::nothrow) T(...)`\n3. **添加空指针检查**：对每个分配结果进行nullptr检查\n4. **设置返回值**：分配失败时返回合适的错误码或默认值\n\n### 步骤3：验证修复\n```bash\n# 确认所有new都已修复\nrg -n 'new \\\\(' *.cpp\n\n# 确认无遗漏\nrg -n '= new [^(]' *.cpp\n```\n\n## 注意事项\n- 静态变量：确保在访问前进行空指针检查\n- 默认值策略：日志级别函数返回LOG_LEVEL_MIN，布尔函数返回false\n- 避免try-catch：使用std::nothrow模式减少异常处理开销\n- 保持API兼容性：不修改函数签名，仅添加内部检查\n\n## 可选步骤\n- 添加单元测试验证内存分配失败场景\n- 使用静态分析工具验证修复完整性\n- 代码审查时重点关注内存分配模式"
}