{
  "problem_type": "HashMap无限递归问题诊断与修复",
  "content": "# HashMap无限递归问题诊断与修复方法论\n\n## 问题描述\nHashMap实现中的rehash操作触发无限递归循环，导致测试超时或程序崩溃。\n\n## 可复用解决流程\n\n### 步骤1：症状识别\n- 运行测试时出现超时（>60秒）\n- 程序崩溃报告内存错误（如\"free(): invalid pointer\"）\n- 使用`cargo test`卡死在特定HashMap相关测试\n\n### 步骤2：定位根因\n1. 运行针对性测试：```cargo test test_hashmap -- --nocapture```\n2. 检查rehash函数的调用链是否形成递归循环\n3. 重点查看rehash是否调用了可能触发再次rehash的函数\n\n### 步骤3：修复方案\n**最小改动原则：**\n- 不修改函数签名，仅优化内部实现\n- 在rehash中直接操作数据结构，避免调用可能触发递归的函数\n\n**具体修复：**\n```rust\n// 避免在rehash中调用get_or_insert_entry\n// 改为直接操作新桶数组\nfor j in 0..map.capacity {\n    let idx = ((hash as i64 + j as i64) % map.capacity as i64) as i32;\n    let new_ent = map.buckets.add(idx as usize);\n    if (*new_ent).key.is_null() || (*new_ent).key == TOMBSTONE {\n        // 直接插入\n        (*new_ent).key = key.as_ptr();\n        (*new_ent).keylen = key.len() as i32;\n        (*new_ent).val = (*old_entry).val;\n        map.used += 1;\n        break;\n}\n}\n```\n\n### 步骤4：验证修复\n1. 使用`timeout 60 cargo test common::hashmap`验证测试通过\n2. 确认无内存泄漏或无效指针错误\n3. 检查所有相关测试在合理时间内完成\n\n## 注意事项\n- 保持接口稳定性，仅修改内部实现\n- 注意空键和边界条件处理\n- 确保内存分配和释放成对出现\n- 考虑线程安全性（如适用）\n\n## 可选步骤\n- 清理未使用的导入和变量警告（低优先级）\n- 统一枚举命名风格（低优先级）"
}