{
  "problem_type": "Rust回归测试验证",
  "content": "问题重述：在Rust项目中，如何系统性地验证代码修改后是否引入回归问题，特别是涉及递归和循环引用的复杂场景。\n\n解决流程：\n1. **环境准备**\n   - 确保项目可编译：`cargo check`\n   - 确认测试结构：检查Cargo.toml中的test配置\n\n2. **全面测试执行**\n   - 执行：`cargo test -- --nocapture`\n   - 观察：确保\"test result: ok. X passed; 0 failed\"\n   - 记录：保存完整输出用于比对\n\n3. **关键测试关注**\n   - 递归测试：test_recursive_function_references\n   - 循环引用测试：test_circular_function_references\n   - 深度递归测试：test_deep_recursion\n   - 边界测试：backend::optimize::tests模块所有测试\n\n4. **结果验证**\n   - 确认所有测试通过（391/391）\n   - 检查特定关注测试的状态\n   - 验证无panic或异常退出\n\n5. **问题定位（如失败）**\n   - 使用`cargo test test_name -- --nocapture`单独运行失败测试\n   - 使用RUST_BACKTRACE=1获取完整堆栈信息\n   - 检查涉及HashMap操作的相关代码变更\n\n注意事项：\n- HashMap修改避免remove/insert模式，使用get_mut就地修改\n- 递归和循环引用测试对对象同一性敏感\n- 每次代码变更后都应运行完整测试套件\n\n可选步骤：\n- 使用cargo test --release验证优化版本\n- 运行clippy检查：`cargo clippy -- -D warnings`\n- 使用cargo bench检查性能回归"
}