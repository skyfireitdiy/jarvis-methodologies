{
  "problem_type": "C函数到Rust迁移（TDD方式）",
  "content": "## 问题重述\n将C语言函数迁移到Rust，使用TDD（测试驱动开发）方法确保功能正确性和代码质量。\n\n## 可复用解决流程\n\n### 1. 分析阶段\n- 使用 `read_code` 或 `read_symbols` 读取C源码，理解函数功能\n- 分析函数签名，设计Rust等价签名（C指针→Rust引用/Option/Result）\n- 检查依赖函数是否已实现\n\n### 2. TDD流程\n#### Red（编写测试）\n  ```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n   \n    #[test]\n    fn test_基本功能() {\n        // 准备测试数据\n        // 调用函数\n        // 验证结果\n    }\n    }\n  ```\n\n测试用例设计要点：\n- 正常路径测试（基本功能）\n- 边界条件测试（空输入、无效参数）\n- 错误处理测试（文件不存在、权限不足等）\n- 特殊模式测试（如压缩级别、小内存模式等）\n\n#### Green（实现功能）\n- 实现最小可工作代码\n- 类型映射规则：\n  - `char*` → `&str` 或 `String`\n  - `NULL` → `None`\n  - 错误码 → `Result<T, E>`\n  - 文件描述符 → `File` 或 `RawFd`\n- 保持与C语义等价\n\n#### Refactor（优化代码）\n- 使用Rust惯用法\n- 添加文档注释\n- 确保资源正确释放（RAII）\n\n### 3. 集成阶段\n- 在目标模块正确放置函数（注意不要放在`#[cfg(test)]`块内）\n- 在 `src/lib.rs` 导出函数：\n  ```rust\n  pub use module::path::function_name;\n  ```\n- 避免重复导入和重复定义\n\n### 4. 验证阶段\n- 运行 `cargo test` 验证所有测试通过\n- 运行 `cargo build` 确保编译成功\n- 检查静态分析结果\n\n## 注意事项\n\n### 常见陷阱\n1. **函数位置错误**：不要将公开函数放在`#[cfg(test)]`标记后面，否则非测试环境无法访问\n2. **重复定义**：修改代码时注意清理重复的函数定义和导入\n3. **文档注释位置**：文档注释应紧邻函数定义，中间不能有其他标记\n4. **模块导出**：必须在`src/lib.rs`中正确导出才能从crate顶层访问\n\n### 错误处理模式\n- 使用 `Result<T, Error>` 处理可恢复错误\n- 使用 `Option<T>` 表示可能不存在的值\n- 避免 `panic!`，除非是不可恢复的编程错误\n\n### 测试策略\n- 每个公开函数至少3个测试用例\n- 测试文件操作时记得清理临时文件\n- 使用断言宏：`assert!`、`assert_eq!`、`assert!(result.is_ok())`\n\n## 工具使用\n\n### 必备工具\n- `read_code`：读取和分析代码结构\n- `edit_file`：结构化编辑代码（推荐）\n- `execute_script`：运行测试和构建命令\n- `read_symbols`：从C项目读取符号信息\n\n### 调试技巧\n- 编译错误时仔细阅读错误信息，特别是行号和错误类型\n- 使用 `cargo test -- --nocapture` 查看测试输出\n- 分步骤修改，每次只改一处，便于定位问题\n\n## 可选优化\n\n### 性能优化\n- 考虑使用 `&[u8]` 代替 `String` 处理二进制数据\n- 大文件操作使用流式处理\n- 适当使用 `unsafe` 优化热点代码（需充分测试）\n\n### API设计\n- 提供构建器模式处理多参数函数\n- 考虑提供高级和低级两套API\n- 使用泛型提高代码复用性"
}