{
  "problem_type": "Rust测试覆盖率提升",
  "content": "## Rust测试覆盖率提升方法论\n\n### 问题重述\n提升Rust项目的单元测试覆盖率，使其达到指定标准（如line≥85%、region≥70%），解决覆盖率报告中文件未显示的问题。\n\n### 可复用解决流程\n\n#### 阶段1：诊断覆盖率基线\n1. 运行覆盖率测试：`cargo llvm-cov test --features all -p crate_name`\n2. 识别未显示在报告中的文件（可能原因：覆盖率未达标、条件编译代码未执行）\n3. 记录当前覆盖率数据作为基线\n\n#### 阶段2：代码覆盖分析\n1. 使用 read_code 读取目标源代码文件\n2. 读取对应的现有测试文件\n3. 识别未覆盖的代码分支：\n   - 条件编译代码：`#[cfg(feature = \"...\")]`、`#[cfg(not(test))]`\n   - 错误处理路径：各种错误场景的处理逻辑\n   - 边界条件：参数为0、空、极大值等情况\n   - 私有函数逻辑：如task_entry内部循环逻辑\n   - 全局函数的不同状态：初始化前、初始化后、触发前、触发后\n\n#### 阶段3：测试用例补充\n1. 根据未覆盖分支设计测试用例\n2. 每个测试用例包含四部分注释：\n   - 测试分类（功能测试/边界测试/异常测试）\n   - 测试场景描述\n   - 测试用例描述（步骤列表）\n   - 通过准则\n3. 重点覆盖：\n   - 边界值测试\n   - 错误场景测试\n   - 并发场景测试\n   - 全局实例的状态测试\n   - 多次触发/重复操作测试\n\n#### 阶段4：测试验证与修复\n1. 先单独运行模块测试：`cargo test -p crate_name --lib module_name`\n2. 检查测试是否全部通过\n3. 修复失败的测试用例（注意全局实例状态干扰）\n4. 验证编译无错误\n\n#### 阶段5：覆盖率验证\n1. 运行完整覆盖率测试（如果超时，可分步骤验证）\n2. 使用 grep 过滤输出查看特定文件：`| grep -A 5 'filename.rs'`\n3. 检查是否达到目标覆盖率\n\n### 注意事项\n\n1. **条件编译代码**：\n   - `#[cfg(not(test))]` 包裹的代码在测试环境下永远不会执行\n   - 这是正常现象，不需要强制覆盖\n   - 覆盖率报告会自动排除这些代码\n\n2. **全局实例测试**：\n   - 避免测试间的状态干扰\n   - 策略1：使用独立实例而非全局函数\n   - 策略2：在测试开始时重新初始化\n   - 测试 `is_some_and` 逻辑的不同分支\n\n3. **超时问题**：\n   - 完整覆盖率测试可能超过300秒\n   - 验证策略：先运行单元测试，再检查覆盖率\n   - 使用过滤命令避免等待完整输出\n\n4. **测试质量**：\n   - 每个测试独立运行\n   - 避免依赖特定执行顺序\n   - 使用合理的等待时间（根据 wait_time_s 参数）\n\n### 可选步骤\n\n1. **性能优化**：如果测试执行时间过长，考虑使用 `--test-threads` 并行化\n2. **覆盖率过滤**：使用 `--ignore-filename-regex` 排除不需要测试的文件\n3. **文档补充**：将测试用例作为使用示例补充到文档中\n\n### 验证标准\n\n- 所有测试用例运行通过\n- 编译无警告（或仅有无关警告）\n- 覆盖率达到目标：line≥85%、region≥70%（关键功能模块≥90%）\n- 测试文件位于正确目录结构下\n- 每个测试包含完整的四部分注释",
  "scope": "global"
}