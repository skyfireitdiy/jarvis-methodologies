{
  "problem_type": "Rust全局状态测试隔离",
  "content": "## 问题重述\n在将C代码移植到Rust时，全局状态变量会导致测试间的状态污染，造成测试失败。需要确保每个测试用例运行时都有独立的状态环境。\n\n## 可复用解决流程\n\n### 步骤1：识别全局状态变量\n- 查找项目中所有的全局变量（C风格）\n- 标记所有需要测试时重置的状态\n\n### 步骤2：转换为线程安全类型\n- 将C风格全局变量转换为Rust的线程安全类型\n- 对于计数器：使用`AtomicUsize`\n- 对于复杂状态：考虑使用`Mutex<T>`或`RwLock<T>`\n\n### 步骤3：创建重置函数\n- 在测试模块中创建`reset_xxx()`辅助函数\n- 使用`#[cfg(test)]`属性确保仅在测试中可用\n- 实现：将全局状态重置为初始值\n\n示例：\n```rust\n#[cfg(test)]\nfn reset_depth() {\n    DEPTH.store(0, Ordering::Relaxed);\n}\n```\n\n### 步骤4：修改测试用例\n- 在每个测试函数开头调用对应的reset函数\n- 确保调用时机在测试逻辑执行前\n\n### 步骤5：验证修复效果\n- 单独运行失败的测试用例确认通过\n- 批量运行所有测试确认无状态污染\n- 使用`cargo test -- --test-threads=1`避免并发问题\n\n## 注意事项\n- 原子类型操作（如fetch_add）返回的是操作前的值，注意结果计算\n- 对于可能溢出的边界情况，使用wrapping_xxx系列方法保持与C行为一致\n- 测试用例中需要显式设置初始状态（如DEPTH.store(5, Ordering::Relaxed)）\n\n## 可选步骤\n- 对于复杂状态，考虑使用fixture模式\n- 使用once_cell或lazy_static管理复杂全局状态\n- 为每个测试创建独立的状态副本（如果可行）"
}