{
  "problem_type": "Rust并发测试稳定性验证",
  "content": "# Rust并发测试稳定性验证方法论\n\n## 问题重述\n在并发环境下，Rust测试可能出现间歇性失败，主要由于：\n- Mutex poisoning导致的panic\n- 测试间状态污染\n- 竞态条件\n- 全局状态管理不当\n\n## 可复用解决流程\n\n### 步骤1：问题识别\n```bash\n# 运行多次测试重现间歇性失败\nfor i in {1..10}; do\n    echo \\\"第$i次运行...\\\"\n    cargo test <模块名> -- --nocapture\ndone\n```\n\n### 步骤2：并发问题定位\n使用工具：\n- 搜索Mutex相关panic：`grep -i \\\"poison\\\" <测试输出>`\n- 检查全局状态访问：`rg \\\"static.*Mutex\\\" src/`\n- 验证测试隔离性：`rg \\\"reset_.*files\\\\|cleanup\\\" tests/`\n\n### 步骤3：修复策略实施\n```rust\n// 1. 增强Mutex错误处理\nuse std::sync::Mutex;\nuse once_cell::sync::Lazy;\n\nstatic GLOBAL_STATE: Lazy<Mutex<Vec<String>>> = Lazy::new(|| Mutex::new(Vec::new()));\n\npub fn safe_access_global() -> Result<(), String> {\n    let guard = match GLOBAL_STATE.lock() {\n        Ok(guard) => guard,\n        Err(e) => {\n            eprintln!(\"警告: Mutex被poisoned，正在恢复...\");\n            e.into_inner()\n}\n    };\n    // 使用guard进行操作\n    Ok(())\n}\n\n// 2. 实现测试隔离\n#[cfg(test)]\npub fn reset_global_state() {\n    let guard = match GLOBAL_STATE.lock() {\n        Ok(guard) => guard,\n        Err(e) => {\n            eprintln!(\"警告: Mutex被poisoned，正在恢复...\");\n            e.into_inner()\n}\n    };\n    guard.clear();\n    assert!(guard.is_empty(), \"全局状态应该为空\");\n}\n```\n\n### 步骤4：验证修复效果\n```bash\n# 运行10次验证稳定性\nfor i in {1..10}; do\n    if ! cargo test util::temp -- --nocapture; then\n        echo \\\"第$i次运行失败\\\"\n        exit 1\n    fi\ndone\necho \\\"所有测试稳定通过\\\"\n```\n\n## 注意事项\n1. 保持API不变，最小化改动\n2. 不引入新依赖\n3. 代码简洁，避免过度设计\n4. 添加必要的错误处理和日志记录\n5. 确保测试间状态隔离\n\n## 可选步骤\n- 使用`cargo test --test-threads=1`先验证单线程稳定性\n- 使用`std::sync::RwLock`替换Mutex如果读多写少\n- 考虑使用`std::sync::Arc<Mutex<T>>`如果需要在多个测试间共享状态"
}