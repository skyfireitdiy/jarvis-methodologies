{
  "problem_type": "Rust并发测试状态污染排查",
  "content": "## Rust并发测试状态污染排查方法论\n\n### 问题症状\n- 测试单独运行通过，但批量运行失败\n- 测试返回意外值（如usize::MAX）\n- 测试间共享状态（static变量）污染\n\n### 解决流程\n1. **症状识别**\n   - 运行：`cargo test test_name -- --nocapture`（单独测试）\n   - 运行：`cargo test -- --nocapture`（批量测试）\n   - 对比结果差异\n\n2. **并发验证**\n   - 运行：`cargo test -- --test-threads=1`\n   - 如果通过→确认为并发状态污染\n   - 如果失败→继续检查逻辑错误\n\n3. **状态隔离检查**\n   - 检查测试是否使用`reset_*()`函数重置状态\n   - 确认所有测试用例是否独立设置初始状态\n   - 验证static变量是否在测试间正确隔离\n\n4. **边界处理**\n   - 对于usize等无符号整数，使用`wrapping_*`系列方法\n   - 模拟C语言的无符号整数溢出行为\n   - 在移植代码中特别注意边界值处理\n\n### 注意事项\n- 全局状态的测试需要串行执行（--test-threads=1）\n- 并发测试时每个测试用例应独立设置所有依赖状态\n- 移植C代码时需考虑无符号整数运算差异\n\n### 可选工具\n- 使用`cargo nextest`提供更灵活的并发控制\n- 添加测试隔离fixture确保状态重置"
}