{
  "problem_type": "编译器后端转译实现",
  "content": "方法论：编译器后端转译实现流程\n\n## 问题重述\n将C语言编译器后端功能转译为Rust实现，需保持功能等价性，处理ABI调用约定、内存布局、寄存器分配等底层细节。\n\n## 可复用解决流程\n\n### 阶段1：需求分析\n1. **识别ABI规范**：确定目标平台调用约定（System V ABI/Windows ABI等）\n2. **数据结构映射**：分析C结构体到Rust结构的字段对应关系\n3. **功能边界确认**：明确需要转译的核心功能范围\n\n### 阶段2：代码分析\n工具组合使用：\n- `read_code`读取目标文件完整结构\n- `lsp_client`查询符号定义和引用关系\n- 重点分析：参数传递机制、栈帧布局、对齐规则\n\n### 阶段3：实现设计\n1. **常量定义**：将C宏转换为Rust const\n2. **类型适配**：处理C指针到Rust Option<Box>的转换\n3. **算法迁移**：保持原有算法逻辑，适配Rust语法\n\n### 阶段4：实现验证\n1. **语法检查**：确保无编译错误\n2. **功能验证**：通过测试用例确认行为一致性\n3. **边界测试**：验证特殊类型（结构体/数组/浮点）处理\n\n### 阶段5：代码优化\n1. **内存安全**：利用Rust借用检查器消除悬垂指针\n2. **性能优化**：使用迭代器替代循环，减少边界检查\n3. **错误处理**：将C的未定义行为转换为Rust的Result类型\n\n## 注意事项\n- 严格遵循目标平台的ABI规范\n- 保持与C实现的位级兼容性\n- 注意Rust的所有权系统对链表操作的影响\n- 浮点类型需特殊处理寄存器分配\n\n## 可选步骤\n- [ ] 添加内联汇编验证测试\n- [ ] 实现符号调试信息生成\n- [ ] 添加性能基准测试对比"
}