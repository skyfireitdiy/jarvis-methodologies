{
  "problem_type": "Rust 并发安全修复",
  "content": "### Rust 并发安全修复方法论\n\n**问题识别**\n- 测试在并发执行时出现竞争条件（race condition）\n- 典型症状：`free(): double free detected`、`assertion 'left == right' failed`\n- 单线程测试通过，但并发测试不稳定失败\n\n**根本原因排查**\n1. 检查全局变量是否使用 `static mut`（不安全的静态变量）\n2. 检查全局状态是否有适当的同步机制（Mutex/RwLock/Atomic）\n3. 检查 once_cell::sync::Lazy 是否配合 Mutex 使用\n\n**修复步骤**\n1. 将 `static mut NAME: Type` 替换为 `static NAME: Lazy<Mutex<Type>>`\n2. 更新所有写访问：\n   ```rust\n   // 之前\n   unsafe { NAME = value; }\n   // 之后\n   let mut guard = NAME.lock().unwrap_or_else(|e| e.into_inner());\n   *guard = value;\n   drop(guard);\n   ```\n3. 更新所有读访问：\n   ```rust\n   // 之前\n   unsafe { let val = &*std::ptr::addr_of!(NAME); }\n   // 之后\n   let guard = NAME.lock().unwrap_or_else(|e| e.into_inner());\n   let val = guard.as_ref().unwrap();\n   ```\n4. 添加辅助函数用于测试访问（如 `get_xxx()`）\n5. 使用 `unwrap_or_else(|e| e.into_inner())` 处理 poisoned Mutex\n\n**验证方法**\n1. 单线程测试验证功能正确性：`cargo test -- --test-threads=1`\n2. 并发测试验证并发安全性：`cargo test`（多次运行确保稳定）\n3. Clippy 检查确保没有新警告：`cargo clippy`\n\n**注意事项**\n- `static mut` 是代码异味，应避免使用\n- 任何全局可变状态都需要同步保护\n- 测试中避免依赖全局状态的执行顺序\n- 使用 `#[cfg(test)]` 标记测试专用代码"
}