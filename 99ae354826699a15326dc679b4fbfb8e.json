{
  "problem_type": "Rust全局状态并发测试清理",
  "content": "问题重述：\n在Rust项目中，当多个测试共享全局状态时（如临时文件列表、缓存等），需要确保测试之间状态完全隔离，避免并发测试导致的竞态条件和不一致状态。\n\n可复用解决流程：\n1. 状态设计阶段\n   - 使用`once_cell::sync::Lazy<Mutex<T>>`创建全局状态\n   - 确保状态类型实现了适当的清理方法\n  \n2. 清理函数实现\n   - 实现reset_xxx()函数，包含完整的清理逻辑\n   - 处理mutex poison错误：使用match处理锁获取失败\n   - 清理所有相关资源：文件删除、内存清空、验证状态\n   - 添加日志记录清理过程，便于调试\n\n3. 测试集成\n   - 每个测试函数开头调用reset_xxx()\n   - 使用#[cfg(test)]条件编译标记测试专用代码\n   - 验证清理后的初始状态\n\n4. 并发安全处理\n   - 使用标准库Mutex保护共享数据\n   - 处理mutex poison：使用guard.into_inner()恢复\n   - 确保锁的及时释放（drop显式释放）\n\n5. 验证机制\n   - 添加断言验证状态确实被清理\n   - 检查临时文件确实被删除\n   - 运行并行测试验证隔离性\n\n注意事项：\n- 避免在测试间共享可变全局状态，如果必须共享，确保完全隔离\n- 清理函数应该是幂等的，多次调用无副作用\n- 考虑清理失败的情况，记录错误但不中断测试\n- 使用`#[cfg(test)]`确保测试代码不会影响生产构建\n\n可选步骤：\n- 使用tempfile crate确保临时文件自动清理\n- 实现Drop trait自动清理资源\n- 添加测试钩子（test harness hooks）统一处理状态清理"
}