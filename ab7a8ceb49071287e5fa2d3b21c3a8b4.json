{
  "problem_type": "功能移除与自动化改造",
  "content": "# 功能移除与自动化改造方法论\n\n## 规则简介\n\n本方法论用于指导\"删除配置项并改为自动化实现\"的任务。这类任务的核心是：移除用户配置选项，改为系统自动决策并执行，同时保持向后兼容性和良好的用户体验。\n\n典型场景包括：\n- 删除\"是否启用某个功能\"的配置，改为自动检测并启用\n- 删除\"手动选择模式\"的配置，改为根据环境自动切换\n- 简化配置选项，减少用户认知负担\n\n## 你必须遵守的原则\n\n### 原则1：完整删除原则\n\n**要求说明：**\n\n- **必须**：删除配置项的所有痕迹，包括代码、配置schema、文档\n- **必须**：通过搜索确认没有残留引用\n- **禁止**：保留已废弃的配置项（除非有明确的兼容性需求）\n\n**验证方法：**\n   ```bash\n# 搜索所有可能的引用\n   rg \"config_name\" --type py --type yaml --type toml --type json --type md\n```\n\n### 原则2：自动化决策原则\n\n**要求说明：**\n\n- **必须**：设计清晰的自动决策逻辑（基于环境、上下文、状态等）\n- **必须**：在日志中清晰说明自动操作的原因和过程\n- **必须**：保留必要的保护机制（如非交互模式下的特殊处理）\n- **禁止**：自动执行可能破坏性或不可逆的操作\n\n### 原则3：小步重构原则\n\n**要求说明：**\n\n- **必须**：按依赖顺序逐步修改，避免大范围改动\n- **必须**：每次修改后立即提交，保持可回退\n- **必须**：先修改使用该配置的逻辑，再删除配置定义\n- **禁止**：一次性修改多个文件后再测试\n\n## 你必须执行的操作\n\n### 阶段1：分析阶段\n\n1. **搜索所有引用位置**：\n   ```bash\n   rg \"config_name\" --type py --type yaml --type toml --type json --type md -l\n```\n\n2. **分析依赖关系和使用场景**：\n   - 配置在哪些地方被读取？\n   - 配置如何影响系统行为？\n   - 改为自动化后，新的决策逻辑是什么？\n\n3. **制定自动化方案**：\n   - 明确自动检测的触发条件\n   - 设计自动决策的判断逻辑\n   - 保留必要的保护机制（如非交互模式）\n\n### 阶段2：代码修改阶段\n\n**按以下顺序执行（必须遵守）：**\n\n1. **修改使用该配置的逻辑**：\n   - 将\"基于配置的分支逻辑\"改为\"自动检测逻辑\"\n   - 添加清晰的日志说明自动操作\n   - 保留必要的保护判断（如 `is_non_interactive()`）\n\n2. **删除导入语句**：\n   - 删除配置函数的导入\n   - 删除未使用的其他导入\n\n3. **删除配置函数**：\n   - 删除配置获取函数（如 `is_enable_xxx()`）\n   - 删除相关的辅助函数（如果存在）\n\n4. **删除配置schema**：\n   - 从 `config_schema.json` 或类似文件中删除配置项定义\n   - 确保删除后schema仍然有效（可以运行验证）\n\n5. **清理相关注释**：\n   - 删除或更新提到该配置的注释\n   - 更新函数/类的文档字符串\n\n### 阶段3：文档更新阶段\n\n1. **更新用户文档**：\n   - 删除配置项的说明\n   - 添加新的自动化行为说明\n   - 说明保护机制（如\"非交互模式下不会自动执行\"）\n\n2. **更新配置示例**：\n   - 从配置文件示例中删除该配置项\n   - 确保示例配置仍然有效\n\n3. **更新配置参考**：\n   - 从配置项表格中删除该配置\n   - 确保表格格式正确\n\n### 阶段4：验证阶段\n\n1. **残留引用检查**：\n   ```bash\n   rg \"config_name\" --type py --type yaml --type toml --type json --type md\n```\n   预期结果：无输出\n\n2. **静态检查**：\n   ```bash\n   # Python项目\n   ruff check src/\n   mypy src/\n  \n   # 或其他语言的静态检查工具\n```\n\n3. **功能测试**：\n   - 测试自动化逻辑是否正常工作\n   - 测试保护机制是否生效\n   - 确认没有引入新的bug\n\n## 实践指导\n\n### 最佳实践\n\n1. **清晰的日志输出**：\n```python\n   # 好的做法\n   logger.info(\"ℹ️ 检测到当前位于 Git 仓库: %s\", git_root)\n   logger.info(\"ℹ️ 正在自动切换到 'jca' 以进入代码开发模式...\")\n```\n\n2. **保留保护机制**：\n```python\n   # 非交互模式下不执行自动操作\n   if is_non_interactive():\n       return\n```\n\n3. **合理的自动决策逻辑**：\n```python\n   # 基于环境检测，而不是随机或猜测\n   if os.path.exists(\"/usr/bin/git\"):\n       enable_git_feature()\n```\n\n### 常见错误\n\n1. **忘记更新文档**：\n   - 代码已删除配置，但文档还在说明如何配置\n   - **后果**：用户困惑，尝试配置无效选项\n\n2. **删除配置但保留使用逻辑**：\n   - 删除了配置项，但代码还在尝试读取\n   - **后果**：运行时错误或KeyError\n\n3. **缺少保护机制**：\n   - 在所有场景下都自动执行，包括CI/CD、脚本等\n   - **后果**：意外行为，破坏自动化流程\n\n4. **一次性修改多个文件**：\n   - 同时修改代码、配置、文档，难以定位问题\n   - **后果**：调试困难，回滚复杂\n\n### 注意事项\n\n1. **向后兼容性**：\n   - 如果配置文件中存在已删除的配置项，系统应该忽略而不是报错\n   - 可以考虑添加迁移提示（如日志警告）\n\n2. **用户体验**：\n   - 自动化操作应该对用户可见（日志输出）\n   - 如果可能，提供禁用自动化的方法（如命令行参数）\n\n3. **测试覆盖**：\n   - 为新的自动决策逻辑添加测试\n   - 测试边界场景（如非交互模式）\n\n## 检查清单\n\n完成功能移除与自动化改造后，确认以下各项：\n\n### 代码完整性\n- [ ] 所有引用该配置的代码已修改\n- [ ] 配置获取函数已删除\n- [ ] 配置schema定义已删除\n- [ ] 相关导入语句已清理\n- [ ] 相关注释已更新\n\n### 文档完整性\n- [ ] 用户文档已更新（说明新的自动化行为）\n- [ ] 配置示例已更新（删除该配置项）\n- [ ] 配置参考已更新（删除配置项说明）\n- [ ] API文档已更新（如果涉及API变更）\n\n### 功能正确性\n- [ ] 自动决策逻辑工作正常\n- [ ] 保护机制生效（如非交互模式）\n- [ ] 没有残留的配置引用\n- [ ] 静态检查通过\n- [ ] 功能测试通过\n\n### 用户体验\n- [ ] 日志输出清晰说明自动操作\n- [ ] 用户体验良好（不会感到困惑）\n- [ ] 向后兼容（旧配置不会导致错误）\n\n## 示例参考\n\n### 示例1：删除\"Git仓库检测提示\"配置，改为自动切换\n\n**原始需求**：\n用户需要在Git仓库中手动确认是否切换到代码开发模式。\n\n**改造方案**：\n1. 删除 `enable_git_jca_switch` 配置项\n2. 改为自动检测Git仓库并切换\n3. 非交互模式下不切换\n\n**关键代码**：\n```python\n# 改造前\nif is_enable_git_jca_switch():\n    if user_confirm(\"检测到Git仓库，是否切换？\"):\n        switch_to_jca()\n\n# 改造后\nif not is_non_interactive():\n    if is_git_repo():\n        logger.info(\"ℹ️ 正在自动切换到代码开发模式...\")\n        switch_to_jca()\n```\n\n**文档更新**：\n```markdown\n- 配置项：`enable_git_jca_switch: true`\n+ 注意：当在 Git 仓库中运行时，Jarvis 会自动检测并切换到代码开发模式。\n```\n\n### 示例2：删除\"手动选择构建工具\"配置，改为自动检测\n\n**原始需求**：\n用户需要手动指定使用哪个构建工具（make/cmake/ninja）。\n\n**改造方案**：\n1. 删除 `build_tool` 配置项\n2. 改为按优先级自动检测可用的构建工具\n3. 提供命令行参数覆盖自动检测\n\n**关键代码**：\n```python\n# 改造前\nbuild_tool = config.get(\"build_tool\", \"make\")\n\n# 改造后\ndef detect_build_tool():\n    for tool in [\"ninja\", \"cmake\", \"make\"]:\n        if shutil.which(tool):\n            return tool\n    return \"make\"  # 默认fallback\n\nbuild_tool = args.build_tool or detect_build_tool()\n```",
  "scope": "global"
}