{
  "problem_type": "修复测试竞态条件问题",
  "content": "|||\n## 问题描述\n\n当多个测试并行执行时，如果测试之间存在共享状态（如全局变量、静态变量、HashMap 等），可能会出现竞态条件导致测试随机失败。\n\n典型症状：\n- 单个测试运行时通过，但批量运行测试时失败\n- 测试结果不稳定，有时通过有时失败\n- 断言失败的值与预期值差距很大（说明状态被其他测试修改）\n\n## 可复用解决流程\n\n### 步骤1：识别共享状态\n1. 查看失败测试的断言值，与预期值对比\n2. 搜索测试代码中使用 `static` 或 `lazy_static` 定义的可变状态\n3. 查找直接修改全局状态的函数（如 `clear_xxx()`, `reset_xxx()`）\n\n### 步骤2：添加全局锁\n```rust\nuse std::sync::Mutex;\n\n// 在测试模块开头添加\nstatic TEST_LOCK: Mutex<()> = Mutex::new(());\n```\n\n### 步骤3：为测试添加锁保护\n\n**方案A：使用 setup 函数返回 guard**\n```rust\nfn setup_test_env() -> MutexGuard<'static, ()> {\n    let _guard = TEST_LOCK.lock().unwrap_or_else(|e| e.into_inner());\n    // 初始化共享状态\n    clear_xxx();\n    init_xxx();\n    _guard  // 返回 guard，保持锁\n}\n\n#[test]\nfn test_xxx() {\n    let _guard = setup_test_env();  // 捕获 guard\n    // 测试断言...\n    // guard 在函数结束时释放\n}\n```\n\n**方案B：直接在测试中添加锁**\n```rust\n#[test]\nfn test_xxx() {\n    let _guard = TEST_LOCK.lock().unwrap_or_else(|e| e.into_inner());\n    clear_xxx();\n    // 测试断言...\n}\n```\n\n### 步骤4：验证修复\n- 单个运行测试：`cargo test test_name`\n- 批量运行测试：`cargo test`（多次运行确认稳定性）\n\n## 注意事项\n\n1. **锁的范围**：确保测试中所有访问共享状态的代码都在锁的保护范围内\n2. **Guard 生命周期**：如果使用 setup 函数返回 guard，确保调用方捕获并保持 guard 到测试结束\n3. **避免死锁**：不要在持有锁时调用可能阻塞的操作\n4. **性能考虑**：锁会串行化测试，但这是必要的权衡\n\n## 可选步骤\n\n- 如果多个模块需要共享锁，可以将锁提取到公共模块（如 `src/codegen/mod.rs`）并导出\n- 使用 `RwLock` 替代 `Mutex` 如果读多写少的场景可以提高并发度"
}