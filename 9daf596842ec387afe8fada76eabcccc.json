{
  "problem_type": "代码验证",
  "content": "# 代码验证方法论\n\n## 问题重述\n验证代码修改是否符合预期，包括功能实现、配置迁移、废弃处理等场景。\n\n## 通用验证流程\n\n### 1. 解析预期输出为可验证条目\n- 将预期输出按换行、编号（1)、2)、3)）或 markdown 列表拆分为独立条目\n- 每个条目应该是一个可独立验证的具体要求\n- 明确每个条目对应的验证标准\n\n### 2. 定位目标代码\n- 使用 `rg -n 'pattern'` 定位函数、类或配置项的准确位置\n- 记录文件路径和行号范围\n- 确认目标代码存在且可访问\n\n### 3. 读取并分析代码\n- 使用 `read_code` 读取目标代码的完整实现\n- 分析代码逻辑是否符合预期\n- 检查是否有语法错误或明显的逻辑问题\n\n### 4. 逐条验证预期输出\n对每个预期输出条目：\n- 在实际代码中查找对应的实现\n- 验证实现是否完整且正确\n- 标记验证结果（PASSED/FAILED）\n- 记录验证依据（具体代码行号和内容）\n\n### 5. 综合判定\n- 只有**所有条目**都验证通过，整体才判定为 PASSED\n- 任何一个条目失败，整体判定为 FAILED\n- 提供详细的验证报告，包括每个条目的验证状态和依据\n\n## 特定场景：配置废弃验证\n\n### 验证要点\n1. **废弃配置不再被收集**\n   - 检查是否移除了配置收集相关的函数调用（如 `_ask_config_optional_str`）\n   - 确认函数不再处理废弃的配置项\n\n2. **提供迁移指引**\n   - 检查文档字符串或注释中是否有清晰的迁移说明\n   - 验证是否提供了新配置的使用示例（推荐使用 YAML 格式）\n   - 确认说明了新旧配置的对应关系\n\n3. **向后兼容性**\n   - 检查是否有向后兼容性说明或处理逻辑\n   - 确认旧配置仍可工作（如果要求保持兼容）\n\n4. **函数返回值**\n   - 废弃的配置收集函数通常返回 `False`（表示无配置修改）\n   - 验证返回值是否符合预期\n\n### 验证示例\n```bash\n# 1. 定位函数\nrg -n 'def _collect_.*_config' src/\n\n# 2. 读取函数实现\n# 使用 read_code 工具读取指定行号范围\n\n# 3. 检查要点\n# - 函数体中是否移除了配置收集调用\n# - 是否添加了文档字符串说明迁移方式\n# - 是否返回 False\n# - 是否有向后兼容性说明\n```\n\n## 注意事项\n1. **基于实际验证**：必须读取实际代码，不能推测或假设\n2. **逐条验证**：对每个预期输出条目单独验证，不能笼统判断\n3. **记录依据**：每个验证结果都要有具体的代码行号和内容作为依据\n4. **只验证预期输出**：不要验证与任务预期输出无关的项目\n5. **使用正确工具**：优先使用 `read_code` 读取代码，使用 `execute_script` 执行搜索命令\n\n## 可选步骤\n- 如果涉及配置 Schema 修改，验证 Schema 定义是否正确\n- 如果涉及配置处理逻辑，验证处理函数是否正确实现\n- 使用 Python 语法检查工具（如 `python -m py_compile`）验证语法正确性"
}