{
  "problem_type": "C转译Rust测试修复",
  "content": "## C转译Rust测试修复方法论\n\n### 问题重述\n将C语言编译器代码转译为Rust后，测试用例可能出现失败，包括：\n- 编译错误（缺失函数、类型不匹配）\n- 测试断言失败（输出格式差异）\n- 运行时错误（内存问题、并发问题）\n- 环境依赖问题（文件路径、外部命令）\n\n### 可复用解决流程\n\n#### 阶段1：问题定位\n1. **运行测试** - 使用`cargo test -- --nocapture`获取完整错误信息\n2. **分类问题** - 区分编译错误vs测试失败vs运行时错误\n3. **隔离测试** - 使用`cargo test <具体测试>`单独运行失败用例\n\n#### 阶段2：环境稳定性\n1. **并发控制** - 如遇到内存问题，使用`RUST_TEST_THREADS=1`单线程运行\n2. **调试输出** - 在测试中添加`println!`或`dbg!`输出中间状态\n3. **回溯信息** - 使用`RUST_BACKTRACE=1`获取详细错误栈\n\n#### 阶段3：代码修复\n1. **依赖检查** - 确保所有C函数都有对应的Rust实现\n2. **断言调整** - 对比C和Rust实现，调整测试断言以匹配实际行为\n3. **边界处理** - 特别关注空指针、数组边界、类型转换等C常见问题\n\n#### 阶段4：验证循环\n1. **增量验证** - 每修复一个问题后立即运行相关测试\n2. **回归测试** - 确保修复不引入新问题\n3. **完整验证** - 最终运行全部测试套件确认\n\n### 注意事项\n- 保持最小改动原则，避免大范围重构\n- Rust实现可能与C有细微差异，重点关注功能等价性\n- 测试中的外部依赖（如文件系统）需要特别处理\n- 并发问题优先考虑单线程隔离\n\n### 工具组合\n- `cargo test -- <测试名>` - 精准运行特定测试\n- `RUST_TEST_THREADS=1` - 避免并发问题\n- `RUST_BACKTRACE=1` - 详细错误信息\n- `println!`调试 - 查看中间状态"
}