{
  "problem_type": "Rust并发测试全局状态污染修复",
  "content": "# Rust并发测试全局状态污染修复方法论\n\n## 问题识别\n当Rust测试在并发环境下失败，但单独运行时成功，可能存在全局状态污染问题。\n\n## 解决流程\n\n### 1. 问题诊断\n- **现象识别**：测试失败表现出非确定性行为\n- **日志分析**：查找`Result::unwrap()`失败、边界值异常等错误\n- **隔离测试**：使用`--test-threads=1`参数验证是否为并发问题\n\n### 2. 根因定位\n- **全局状态检查**：查找所有`static`或`lazy_static`定义的全局变量\n- **测试依赖分析**：检查测试用例是否共享和修改全局状态\n- **边界条件验证**：特别关注原子操作的边界值处理\n\n### 3. 解决方案选择\n\n#### 方案A：串行测试（快速解决）\n```bash\ncargo test -- --test-threads=1\n```\n\n#### 方案B：全局状态重置（推荐）\n- 在测试setup阶段重置全局状态\n- 使用`std::sync::Once`确保单次初始化\n- 实现`reset`函数供测试调用\n\n#### 方案C：隔离测试环境\n- 使用测试fixture模式\n- 为每个测试创建独立状态副本\n- 避免直接修改全局状态\n\n### 4. 验证策略\n- 多次运行并发测试验证稳定性\n- 使用`cargo test -- --test-threads=8 --nocapture`高并发验证\n- 监控CI/CD环境中的测试稳定性\n\n## 工具使用建议\n- `execute_script`：用于运行测试和验证修复\n- 测试参数：使用`--test-threads=1`到`--test-threads=N`梯度验证\n\n## 注意事项\n- 全局状态污染是Rust测试常见陷阱\n- 原子操作需正确处理边界值（`usize::MAX`等）\n- 优先选择状态隔离而非串行测试作为长期解决方案"
}