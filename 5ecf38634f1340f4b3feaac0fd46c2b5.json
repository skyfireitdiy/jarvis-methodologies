{
  "problem_type": "UTF-16编码转换实现验证",
  "content": "方法论：UTF-16编码转换实现验证流程\n\n问题重述：\n验证UTF-8到UTF-16编码转换的完整实现，包括代理对生成、字节序处理、边界情况处理，以及与字符串解析器的集成。\n\n可复用解决流程：\n1. 代码定位阶段\n   - 使用 `find . -name \"*.rs\" | xargs grep -l \"utf8_to_utf16\\|UTF.*16\"` 定位实现文件\n   - 核心文件通常为 `src/util/string.rs` 和 `src/lexer/tokenizer.rs`\n\n2. 功能验证阶段\n   - 检查UTF-8到UTF-16转换函数实现：确认处理Unicode范围0x0000-0x10FFFF\n   - 验证代理对生成逻辑：检查U+10000以上字符的代理对计算\n   - 确认字节序处理：使用 `to_le_bytes()` 或 `to_be_bytes()` 明确字节序\n\n3. 集成测试阶段\n   - 验证 `read_utf16_string_literal` 函数是否正确集成转义字符解析和编码转换\n   - 运行相关测试：\n     * `cargo test --package <pkg> --lib util::string -- --nocapture`\n     * `cargo test --package <pkg> --lib tokenizer::tests -- --nocapture`\n\n4. 边界情况验证\n   - 空字符串处理\n   - ASCII字符（0x0000-0x007F）\n   - BMP字符（0x0080-0xFFFF，排除代理对区域）\n   - 辅助平面字符（0x10000-0x10FFFF）\n   - Unicode最大边界值（0x10FFFF）\n\n5. 性能考量\n   - 大字符串处理测试\n   - 多语言字符混合测试\n\n注意事项：\n- 代理对区域(0xD800-0xDFFF)应作为无效字符处理\n- 字节序必须明确指定，避免平台差异\n- 组合字符序列应正确处理\n- 错误输入应有合理的fallback策略\n\n可选步骤：\n- 验证BOM(Byte Order Mark)处理（如需要）\n- 验证大端字节序支持的扩展性\n- 性能基准测试"
}