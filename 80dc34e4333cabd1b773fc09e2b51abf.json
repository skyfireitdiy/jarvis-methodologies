{
  "problem_type": "Rust借用冲突解决",
  "content": "# C函数到Rust转译的借用冲突解决方法论\n\n## 问题重述\n当将C递归函数转译为Rust时，常见的`HashMap<K, V>`借用冲突问题：\n- C通过指针直接修改对象\n- Rust需要避免同时持有多个可变借用\n- `remove/insert`模式破坏对象同一性\n\n## 可复用解决流程\n\n### 步骤1：分析问题类型\n- **类型A**：递归调用中需要修改HashMap\n- **类型B**：需要保持对象同一性\n- **类型C**：需要处理循环引用\n\n### 步骤2：选择解决方案\n\n**方案1：工作队列法（推荐）**\n适用：递归遍历图结构，需要修改节点状态\n```rust\nfn process_recursive(data: &mut HashMap<String, Node>) {\n    let mut work_queue = Vec::new();\n    // 初始收集\n    for (key, node) in data.iter() {\n        if needs_processing(node) {\n            work_queue.push(key.clone());\n}\n}\n   \n    let mut i = 0;\n    while i < work_queue.len() {\n        let current_key = &work_queue[i];\n        i += 1;\n       \n        // 安全检查和修改\n        if let Some(node) = data.get_mut(current_key) {\n            // 处理节点\n            node.processed = true;\n           \n            // 收集新节点\n            for ref_key in &node.references {\n                if let Some(ref_node) = data.get(ref_key) {\n                    if !ref_node.processed && !work_queue.contains(ref_key) {\n                        work_queue.push(ref_key.clone());\n}\n}\n}\n}\n}\n}\n```\n\n**方案2：临时移除法（折中）**\n适用：简单递归，对象数量少\n```rust\nfn process_recursive(data: &mut HashMap<String, Node>) {\n    let keys: Vec<_> = data.keys().cloned().collect();\n    for key in keys {\n        if let Some(mut node) = data.remove(&key) {\n            process_node(&mut node, data);\n            data.insert(key, node);\n}\n}\n}\n```\n\n### 步骤3：验证测试\n1. 运行`cargo test -- --nocapture`\n2. 确保所有相关测试通过\n3. 检查无借用冲突编译错误\n\n### 注意事项\n- 优先使用工作队列避免递归调用\n- 确保对象克隆成本合理\n- 检查循环引用处理逻辑\n- 验证测试覆盖率保持不变\n\n### 可选步骤\n如需进一步优化性能：\n1. 使用迭代器减少内存分配\n2. 考虑使用`RefCell`或`Rc`处理复杂借用场景\n3. 评估是否需要并行处理"
}