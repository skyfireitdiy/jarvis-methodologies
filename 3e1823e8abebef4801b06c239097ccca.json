{
  "problem_type": "C到Rust函数TDD转换",
  "content": "## read_macro_params 函数移植计划\n\n### 1. C 函数分析\n- **C 签名**: `static MacroParam *read_macro_params(Token **rest, Token *tok, char **va_args_name)`\n- **功能**: 读取宏定义的参数列表\n- **返回值**: MacroParam 链表（参数名列表）\n- **输出参数**: rest（剩余tokens）, va_args_name（变长参数名）\n\n### 2. Rust 函数签名\n```rust\npub fn read_macro_params(\n    tokens: &[Token],\n) -> Result<(Vec<MacroArg>, Option<String>, &[Token]), String>\n```\n- 返回: (参数列表 Vec<MacroArg>, 变长参数名 Option<String>, 剩余tokens &[Token])\n\n### 3. C 行为到 Rust 映射\n| C 行为 | Rust 实现 |\n|--------|----------|\n| `while (!equal(tok, \")\"))` | `while !equal(&tokens[0], \")\")` |\n| `tok = skip(tok, \",\")` | `tokens = skip(tokens, \",\")?` |\n| `if (equal(tok, \"...\"))` | `if equal(&tokens[0], \"...\")` |\n| `*va_args_name = \"__VA_ARGS__\"` | 返回 `Some(\"__VA_ARGS__\".to_string())` |\n| `*rest = skip(tok->next, \")\")` | 返回剩余 tokens 切片 |\n| `tok->kind != TK_IDENT` | `tokens[0].kind != TokenKind::Ident` |\n| `strndup(tok->loc, tok->len)` | `tokens[0].text.clone()` |\n\n### 4. 测试用例设计\n**正常路径测试**:\n- 空参数列表: `()` -> (vec![], None, rest)\n- 单个参数: `(x)` -> (vec![MacroArg{name:\"x\"}], None, rest)\n- 多个参数: `(a, b, c)` -> 3个参数的vec\n- 可变参数 `...`: `(a, ...)` -> (vec![a], Some(\"__VA_ARGS__\"), rest)\n- 命名可变参数: `(args...)` -> (vec![], Some(\"args\"), rest)\n- 混合参数: `(a, b...)` -> (vec![a], Some(\"b\"), rest)\n\n**边界测试**:\n- 无参数无括号: 直接返回空 vec\n\n**错误测试**:\n- 非标识符参数: 返回错误 \"expected an identifier\"\n\n### 5. 依赖函数\n- `equal`: tokenizer.rs 中已有\n- `skip`: tokenizer.rs 中已有\n- 无需 strndup/calloc: Rust 直接使用 String 和 Vec"
}