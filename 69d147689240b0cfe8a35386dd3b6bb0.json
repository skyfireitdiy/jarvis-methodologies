{
  "problem_type": "C库版本函数迁移",
  "content": "## 问题重述\n将C库中的版本获取函数（如BZ2_bzlibVersion）迁移到Rust实现，保持语义一致性。\n\n## 可复用解决流程\n\n### 1. 分析C函数实现\n- 使用`read_symbols`或`execute_script`查看C源码\n- 使用`grep`在C源码中查找版本宏定义（通常名为*_VERSION）\n- 理解函数语义：通常返回静态版本字符串\n\n### 2. TDD流程实现\n\n#### 2.1 Red阶段 - 编写测试\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n   \n    #[test]\n    fn test_version_function() {\n        // 测试1：验证版本字符串内容\n        let version = version_function();\n        assert_eq!(version, \"预期版本字符串\");\n       \n        // 测试2：验证静态引用特性\n        let v1 = version_function();\n        let v2 = version_function();\n        assert!(std::ptr::eq(v1, v2), \"应返回相同的静态引用\");\n       \n        // 测试3：验证版本格式（可选）\n        assert!(version.contains(\"版本号\"));\n        assert!(version.contains(\"日期\"));\n    }\n    }\n```\n\n#### 2.2 Green阶段 - 实现函数\n```rust\n/// 返回库的版本字符串\npub fn version_function() -> &'static str {\n    \"从C宏定义获取的版本字符串\"\n    }\n```\n\n#### 2.3 Refactor阶段\n- 确保函数签名符合Rust惯例（snake_case命名）\n- 添加文档注释说明函数用途\n- 验证测试全部通过\n\n### 3. 集成验证\n- 使用`cargo test`运行测试\n- 使用`cargo build`验证编译\n- 确保函数被正确导出（pub关键字）\n\n## 注意事项\n1. **版本字符串必须与C库保持一致**：直接从C源码复制，不要修改格式\n2. **使用&'static str**：版本字符串是编译时常量，使用静态生命周期\n3. **测试完整性**：不仅测试返回值，还要验证静态引用特性\n4. **避免硬编码**：如果版本可能变化，考虑从build.rs读取\n\n## 可选步骤\n- 如果版本字符串需要动态生成，可以使用`const fn`或`build.rs`\n- 可以添加解析版本号的辅助函数（major、minor、patch）\n- 考虑提供与C兼容的FFI接口（如果需要与C代码交互）"
}