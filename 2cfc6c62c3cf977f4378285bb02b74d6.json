{
  "problem_type": "C预处理器Rust转译",
  "content": "# C预处理器到Rust转译方法论\n\n## 问题重述\n将C语言的预处理功能（宏处理、条件编译、头文件包含等）完整移植到Rust实现，要求：\n1. 行为与C预处理器完全一致\n2. 支持所有标准预处理指令\n3. 处理宏展开、字符串化、标记粘贴等高级特性\n4. 保持高性能和内存安全\n\n## 可复用解决流程\n\n### 阶段1：架构设计\n1. **数据结构映射**\n   - C的Token链表 → Rust的Vec<Token>\n   - C的宏哈希表 → Rust的HashMap<String, Macro>\n   - C的隐藏集合 → Rust的Vec<Hideset>\n\n2. **核心接口设计**\n   - 入口函数：`preprocess(tokens: &[Token]) -> Result<Vec<Token>, PreprocessError>`\n   - 状态管理：`PreprocessorState`结构体\n   - 错误处理：`PreprocessError`枚举\n\n### 阶段2：功能实现\n1. **基础框架**\n   ```rust\n   pub struct PreprocessorState {\n       cond_incl: Option<Box<CondIncl>>,  // 条件编译栈\n       macros: HashMap<String, Macro>,    // 宏定义表\n       hidesets: Vec<Hideset>,           // 宏展开隐藏集合\n   }\n   ```\n\n2. **核心处理流程**\n   - `preprocess2()`：主预处理循环\n   - `handle_preprocessor_directive()`：指令分发\n   - `expand_macros()`：宏展开逻辑\n\n3. **指令处理映射**\n   - #define → 创建Macro对象并存储\n   - #if/#ifdef → 维护CondIncl栈\n   - #include → 文件读取和Token化\n   - #undef → 从宏表中移除\n\n### 阶段3：高级特性\n1. **函数式宏处理**\n   - 参数解析：read_macro_args()\n   - 参数替换：subst()\n   - 字符串化：stringize()\n   - 标记粘贴：paste()\n\n2. **递归宏保护**\n   - 隐藏集合机制防止无限递归\n   - 宏名在展开结果中标记为已使用\n\n### 阶段4：测试验证\n1. **测试用例设计**\n   - 基础指令测试：#define, #if, #endif\n   - 宏展开测试：对象式宏和函数式宏\n   - 边界测试：未终止的条件编译\n   - 集成测试：复杂预处理场景\n\n2. **验证工具**\n   ```bash\n   cargo test -- --nocapture\n   ```\n\n## 注意事项\n- 保持Token的line_delta属性用于行号修正\n- 条件编译栈需要处理嵌套情况\n- 宏展开要考虑hide集合防止递归\n- 字符串字面量连接需要特殊处理\n\n## 可选步骤\n- 添加内置宏支持（__LINE__, __FILE__等）\n- 实现#pragma once等扩展指令\n- 支持#include_next等GNU扩展\n- 添加预处理结果缓存机制"
}