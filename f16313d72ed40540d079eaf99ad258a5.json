{
  "problem_type": "Rust测试并发和状态共享问题修复",
  "content": "# Rust测试并发和状态共享问题修复方法论\n\n## 问题重述\nRust测试中由于共享状态（如全局静态变量）导致的并发问题，包括：\n- Mutex PoisonError\n- 测试间状态污染\n- 计数/状态不一致\n\n## 可复用解决流程\n\n### 步骤1：问题诊断\n1. 运行单个测试确认问题：`cargo test test_name -- --nocapture`\n2. 运行整个测试套件确认稳定性：`cargo test -- --nocapture`\n3. 识别共享状态变量位置\n\n### 步骤2：修复方案\n1. **Mutex PoisonError 处理**：\n   ```rust\n   // 替换 unwrap() 为：\n   my_mutex.lock().unwrap_or_else(|e| e.into_inner())\n   ```\n\n2. **状态重置**：\n   ```rust\n   // 在每个测试开始前重置共享状态\n   let global = GLOBAL.get_or_init(|| Mutex::new(initial_value));\n   *global.lock().unwrap_or_else(|e| e.into_inner()) = new_value;\n   ```\n\n3. **测试隔离**：\n   - 避免测试间共享可变状态\n   - 或使用setup/teardown模式重置状态\n\n### 步骤3：验证修复\n1. 运行完整测试套件：`cargo test -- --nocapture`\n2. 多次运行确认稳定性\n3. 检查是否有回归问题\n\n## 注意事项\n- 保持最小改动原则\n- 修复后必须验证所有测试通过\n- 考虑使用临时文件或setup/teardown模式\n- 注意测试执行顺序可能影响结果\n\n## 可选步骤\n- 使用 `std::sync::OnceLock` 替代 `lazy_static` 获得更好测试控制\n- 考虑使用 `tempfile` crate 进行临时状态管理\n- 对于复杂状态，可设计专用的测试工具函数"
}