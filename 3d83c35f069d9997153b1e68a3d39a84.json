{
  "problem_type": "C函数到Rust翻译",
  "content": "# C函数到Rust翻译方法论\n\n## 问题重述\n将C语言中的函数（特别是涉及全局变量和链表操作的）翻译为符合Rust所有权语义的安全实现。\n\n## 可复用解决流程\n\n### 步骤1：函数签名分析\n- 识别C函数参数类型：`char*` → `String`，`Type*` → `Box<Type>`\n- 确定返回值类型：`Obj*` → `Box<Obj>`\n- 记录函数用途和副作用（如修改全局变量）\n\n### 步骤2：全局变量处理\n- 若C代码使用全局变量 `static Obj* locals = NULL;`\n- Rust实现：`static LOCALS: OnceLock<Mutex<Option<Box<Obj>>>> = OnceLock::new();`\n- 使用 `get_or_init` 延迟初始化，`Mutex` 保证线程安全\n\n### 步骤3：链表操作转换\n- C链表插入：`var->next = locals; locals = var;`\n- Rust链表插入：\n  ```rust\n  var.next = locals_guard.take();\n  *locals_guard = Some(var.clone());\n  ```\n\n### 步骤4：内存管理映射\n- C的`malloc` → Rust的`Box::new`\n- C的指针 → Rust的`Box`智能指针\n- 确保Clone trait实现用于链表节点共享\n\n### 步骤5：代码集成\n1. 使用 `read_code` 读取目标文件末尾\n2. 使用 `edit_file` 的精确尾部匹配添加新函数\n3. 确保新增 `use` 语句不影响现有代码\n\n## 注意事项\n- 保持原有函数语义不变\n- 利用Rust类型系统增强安全性\n- 避免内存泄漏，确保所有分配都有明确的所有者\n- 复杂类型可能需要实现Clone、Debug等trait\n\n## 验证步骤\n- 编译检查：`cargo check`\n- 逻辑验证：确保链表操作正确维护变量作用域\n- 内存安全：确认无悬垂指针或重复释放"
}