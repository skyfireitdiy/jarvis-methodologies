{
  "problem_type": "单元测试补充",
  "content": "# 单元测试补充方法论\n\n## 规则简介\n\n本方法论提供为现有代码补充单元测试的标准化流程，确保测试覆盖率达到目标要求，同时保证代码功能不受影响。\n\n## 你必须遵守的原则\n\n### 测试完整性原则\n\n**要求说明：**\n- **必须**：为所有公开方法和类补充单元测试\n- **必须**：测试覆盖正常场景和边界情况\n- **必须**：使用mock隔离外部依赖\n- **禁止**：跳过已知的功能测试\n\n### 小步提交原则\n\n**要求说明：**\n- **必须**：每次只补充一类测试或一个方法的测试\n- **必须**：每完成一个测试类后立即验证（pytest -v）\n- **禁止**：一次性添加大量测试而不验证\n\n### 验证标准原则\n\n**要求说明：**\n- **必须**：所有测试用例必须通过（无failures）\n- **必须**：测试覆盖率达到预设目标（如≥90%）\n- **禁止**：提交失败的测试用例\n\n## 你必须执行的操作\n\n### 阶段1：现状分析\n\n1. **步骤1**：读取目标代码文件，分析公开方法列表\n2. **步骤2**：读取现有测试文件，了解已覆盖的测试\n3. **步骤3**：识别缺失的测试用例（特别是静态方法、边界情况）\n4. **步骤4**：运行现有测试，确认当前测试状态（pytest -v）\n\n### 阶段2：补充测试\n\n1. **步骤1**：为每个缺失的方法或类创建对应的测试类或测试方法\n2. **步骤2**：编写测试用例，覆盖：\n   - 正常场景\n   - 边界情况（空值、极值、异常输入）\n   - 错误场景（如适用）\n3. **步骤3**：使用mock隔离外部依赖（console、数据库、网络等）\n4. **步骤4**：运行测试验证通过（pytest tests/xxx/test_module.py -v）\n\n### 阶段3：验证完成\n\n1. **步骤1**：运行完整测试套件，确认所有测试通过\n2. **步骤2**：检查测试数量，确认覆盖所有公开方法\n3. **步骤3**：保存测试覆盖信息到记忆\n\n## 实践指导\n\n### 测试命名规范\n\n- 测试类名：Test + 类名\n- 测试方法名：test + 功能描述\n- 描述性注释：使用文档字符串说明测试目的\n\n### Mock使用技巧\n\n```python\n@patch(\"module.path.to.external_dependency\")\ndef test_method(self, mock_dependency):\n    mock_dependency.return_value = expected_value\n    # 测试逻辑\n```\n\n### 边界测试示例\n\n- 空字符串、None、0、负数\n- 单元素列表/数组\n- 超长字符串\n- 特殊字符\n\n## 检查清单\n\n- [ ] 所有公开方法都有对应的单元测试\n- [ ] 静态方法有专门的测试用例\n- [ ] 边界情况已覆盖\n- [ ] 外部依赖已使用mock隔离\n- [ ] 所有测试用例通过（pytest -v）\n- [ ] 测试覆盖率达到目标\n- [ ] 代码已自动提交",
  "scope": "global"
}