{
  "problem_type": "UTF-8到UTF-16编码转换验证",
  "content": "== UTF-8到UTF-16编码转换验证方法论 ==\n\n### 问题重述\n验证UTF-8字符串到UTF-16编码转换功能的正确性，确保新功能不会破坏现有代码，与现有解析器集成正常，并满足性能要求。\n\n### 可复用解决流程\n\n#### 步骤1: 代码实现验证\n- **工具**: read_code\n- **操作**: 验证utf8_to_utf16函数实现\n- **检查点**:\n  - 正确计算代理对（U+10000及以上）\n  - 处理无效代理对区域（0xD800-0xDFFF）\n  - 边界值处理（最大Unicode码点0x10FFFF）\n\n#### 步骤2: 测试套件验证\n- **工具**: execute_script\n- **命令**: `cargo test -- --nocapture`\n- **验证标准**:\n  - 所有测试通过（34/34）\n  - 新功能测试（6个utf8_to_utf16测试函数）全部通过\n  - 无回归问题（现有测试不受影响）\n\n#### 步骤3: 集成验证\n- **工具**: read_code + execute_script\n- **检查点**:\n  - 与parse_escape_sequences函数的集成\n  - 端到端UTF-16字符串处理流程\n  - 测试用例覆盖ASCII、BMP、辅助平面字符\n\n#### 步骤4: 性能评估\n- **工具**: execute_script\n- **命令**: `time cargo test`\n- **标准**: 测试运行时间<1秒（实际<0.1秒）\n\n### 注意事项\n1. 代理对计算必须使用标准公式：\n   - 高代理 = ((code_point - 0x10000) >> 10) + 0xD800\n   - 低代理 = ((code_point - 0x10000) & 0x3FF) + 0xDC00\n2. 测试覆盖必须包括：边界值、emoji、多语言、特殊字符\n3. 警告信息不影响功能，但建议清理（如未使用变量）\n\n### 可选步骤\n- 使用`cargo test --release`进行性能优化验证\n- 添加fuzzing测试用于边界情况验证"
}