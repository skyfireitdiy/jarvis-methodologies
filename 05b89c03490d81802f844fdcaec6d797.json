{
  "problem_type": "C到Rust函数移植一致性修复",
  "content": "# C到Rust函数移植一致性修复方法论\n\n## 问题重述\n在将C代码移植到Rust时，由于内存布局、类型系统和借用检查器的差异，导致功能实现与原始C代码行为不一致。\n\n## 可复用解决流程\n\n### 阶段1：差异分析\n1. **代码对比**：使用read_code读取Rust实现和C源码\n2. **符号定位**：使用lsp_client搜索关键函数和常量\n3. **依赖检查**：验证所有被调函数是否已实现\n\n### 阶段2：修复实施\n1. **功能实现**：按C逻辑逐行实现，避免过度重构\n2. **类型适配**：处理C指针到Rust引用的转换\n3. **借用修复**：通过作用域隔离和临时变量解决借用冲突\n4. **测试升级**：将简化测试重构为真实场景验证\n\n### 阶段3：验证确认\n1. **单元测试**：运行原有测试确保无回归\n2. **行为验证**：对比C和Rust在相同输入下的输出\n3. **边界测试**：验证异常路径和边界条件\n\n## 注意事项\n- 禁止添加`todo!`或`unimplemented!`占位符\n- 优先使用标准库和项目已有依赖\n- 保持原有函数签名和错误处理模式\n- 每次修改后立即运行测试验证\n\n## 关键工具组合\n- read_code + lsp_client：代码理解\n- edit_file：精准修改\n- cargo test：回归验证\n- sed：批量文本处理（大量删除/替换时）"
}