{
  "problem_type": "并发测试竞态条件修复",
  "content": "问题描述：多线程测试环境中，共享全局状态导致的竞态条件问题。\n\n可复用解决流程：\n\n1. **问题诊断阶段**\n   - 现象识别：测试随机失败，单线程通过但并发失败\n   - 定位工具：使用`cargo test -- --nocapture`观察失败模式\n   - 根因分析：识别涉及全局状态的模块和变量\n\n2. **方案设计阶段**\n   - 最小改动原则：避免业务逻辑变更，仅添加同步机制\n   - 技术选择：优先考虑`std::sync::Mutex`而非线程局部存储\n   - 范围控制：仅对测试代码加锁，不影响生产代码性能\n\n3. **实施阶段**\n   - 在每个测试模块添加静态锁：`static TEST_LOCK: Mutex<()> = Mutex::new(());`\n   - 在每个测试函数开头加锁：`let _guard = TEST_LOCK.lock().unwrap();`\n   - 使用task_list_manager确保所有相关测试都被保护\n\n4. **验证阶段**\n   - 单次验证：`cargo test -- --nocapture`\n   - 并发验证：多次运行测试确认稳定性\n   - 回归验证：确保原有功能不受影响\n\n注意事项：\n- 锁的粒度要适中，避免过度串行化\n- 测试清理函数也需要在锁保护下执行\n- 中文注释保持一致性\n- 验证必须实际执行，不能假设成功\n\n可选步骤：\n- 如问题持续，可考虑使用`std::sync::Once`进行一次性初始化\n- 对于性能敏感场景，可评估读写锁(`RwLock`)的适用性"
}