{
  "problem_type": "AST代码重构",
  "content": "# AST代码重构方法论\n\n## 规则简介\n\n本方法论提供使用Python AST模块进行代码重构的系统性指导，适用于将硬编码模式转换为更优设计的自动化重构工具开发。\n\n## 你必须遵守的原则\n\n### AST节点完整性原则\n\n**要求说明：**\n\n- **必须**：新建的AST节点必须设置lineno属性\n- **必须**：确保生成的代码可以通过语法检查\n- **禁止**：创建不完整的AST节点\n\n示例：new_node.lineno = original_node.lineno\n\n### 类型系统兼容原则\n\n**要求说明：**\n\n- **必须**：优先使用Python 3.10+的|运算符（如Database | None）\n- **必须**：使用ast.BinOp(op=ast.BitOr())生成可选类型\n- **禁止**：使用过时的Union[T, None]语法\n\n### dataclass字段顺序原则\n\n**要求说明：**\n\n- **必须**：有默认值的字段必须放在无默认值字段之后\n- **禁止**：违反dataclass字段声明顺序\n\n### 小步重构验证原则\n\n**要求说明：**\n\n- **必须**：每个重构步骤后立即验证生成的代码语法正确\n- **必须**：保持功能不变（重构前后测试结果一致）\n- **必须**：使用版本控制，每个可验证步骤都提交\n\n## 你必须执行的操作\n\n### 阶段1：AST分析（识别需要重构的代码）\n\n1. 解析源代码：使用ast.parse()解析源代码，捕获SyntaxError异常\n2. 遍历AST树：继承ast.NodeVisitor创建分析器，在visit方法中检测模式\n3. 提取关键信息：记录类名、方法名、行号、依赖类型、参数列表\n\n### 阶段2：AST修改（生成重构后的代码）\n\n1. 复制原始AST：使用copy.deepcopy()复制AST节点\n2. 修改构造函数：添加参数到args.args列表，生成正确的类型注解，添加默认值\n3. 修改赋值语句：创建新的ast.Assign节点，设置正确的lineno属性\n4. 验证生成代码：使用ast.parse()验证语法，使用ast.unparse()生成可读代码\n\n### 阶段3：代码生成与输出\n\n1. 生成容器代码（如需要）：使用字符串拼接或模板，生成lazy loading属性和factory method\n2. 写入文件：原子性写入，保持原有文件编码，保留文件权限\n\n### 阶段4：错误处理与集成\n\n1. 错误检查顺序：先检查基础条件（文件存在、语法正确），再检查业务条件（类存在、方法存在），最后检查重构条件（依赖存在）\n2. 提供准确错误消息：明确指出问题位置，提供修复建议，区分不同错误类型\n3. 集成历史记录（如需要）：记录原始代码和修改后代码，支持回滚操作\n\n## 实践指导\n\n### 常见问题与解决方案\n\n问题1：字符串常量双重引号\n- 现象：repr(Constant(value=\"service\"))返回\"'service'\"\n- 解决：手动格式化字符串常量\n\n问题2：ast.unparse()格式差异\n- 现象：生成的代码可能在=号周围没有空格\n- 解决：测试时兼容多种格式\n\n问题3：FixHistory测试隔离\n- 现象：多个测试共享同一个历史文件\n- 解决：每个测试使用独立的临时文件\n\n### 性能优化建议\n\n- 对于大型文件，使用ast.iter_child_nodes()而非ast.walk()\n- 缓存AST解析结果，避免重复解析\n- 使用生成器处理多个文件，减少内存占用\n\n## 检查清单\n\n完成AST代码重构后，必须确认：\n\n- 所有新建的AST节点都设置了lineno属性\n- 生成的代码能通过ast.parse()语法检查\n- 类型注解使用Python 3.10+的|运算符（如适用）\n- dataclass字段声明顺序正确（有默认值在后）\n- 错误检查顺序合理（先基础后业务）\n- 错误消息准确清晰（指出位置和建议）\n- 测试覆盖率达到90%以上\n- 所有测试通过（功能未改变）\n- 静态扫描通过（ruff + mypy）\n- 代码风格与现有重构器一致",
  "scope": "global"
}