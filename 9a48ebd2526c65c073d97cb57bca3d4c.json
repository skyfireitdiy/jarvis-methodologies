{
  "problem_type": "C到Rust移植代码修复",
  "content": "## C到Rust移植代码修复方法论\n\n### 问题重述\n处理C代码迁移到Rust时产生的功能一致性问题，包括：\n- 魔法数字未替换为常量\n- 循环控制逻辑错误\n- 结构体定义冲突\n- 内存布局兼容性问题\n\n### 可复用解决流程\n\n#### 阶段1：问题定位\n1. **读取原始C代码**：使用read_code获取对应C函数实现\n2. **对比Rust实现**：定位差异点和潜在问题\n3. **识别修复类型**：按以下分类处理\n   - 硬编码常量 → 替换为预定义常量\n   - 循环逻辑错误 → 修正控制流\n   - 结构体冲突 → 本地重命名或提取\n\n#### 阶段2：常量修复\n1. **检查constants.rs**：确认所需常量是否已定义\n2. **添加缺失常量**：\n   ```\n   pub const LFS_TYPE_DELETE: u32 = 0x200;\n   ```\n3. **更新use语句**：导入所需常量到使用模块\n4. **批量替换**：将魔法数字替换为常量引用\n\n#### 阶段3：循环修复\n1. **识别循环模式**：查找while循环内的计数器定义\n2. **修复循环变量**：\n   ```\n   // 错误\n   while condition {\n       let mut iterations = 0;  // 每次重置\n       ...\n   }\n  \n   // 正确\n   let mut iterations = 0;      // 循环外部\n   while condition {\n       ...\n       iterations += 1;\n   }\n   ```\n\n#### 阶段4：结构体冲突处理\n1. **避免命名冲突**：使用Raw前缀（如RawMlistEntry）\n2. **保持内存布局**：使用#[repr(C)]和相同字段顺序\n3. **验证布局**：确保sizeof检查通过\n\n#### 阶段5：验证\n1. **构建检查**：cargo build\n2. **测试验证**：cargo test -- --nocapture\n3. **回归测试**：确保修复不影响其他功能\n\n### 注意事项\n- 每次只修改一个类型的问题\n- 保持最小改动原则\n- 优先修复构建错误\n- 确保测试覆盖率\n\n### 可选步骤\n- 对于复杂内存操作，使用assert验证布局\n- 添加适当的注释说明移植来源\n- 考虑使用bindgen验证结构体布局"
}