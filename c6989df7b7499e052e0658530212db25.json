{
  "problem_type": "枚举字典映射KeyError修复",
  "content": "## 问题描述\n当看到错误信息格式为 `<EnumType.VALUE: 'value'>` 时，表示Python枚举对象被转换为字符串，通常是因为字典访问时发生了KeyError异常。\n\n## 问题原因\n代码中定义了枚举类型，但后续使用的字典没有包含所有枚举值，导致在访问字典时KeyError。Python捕获异常后将枚举对象转换为字符串显示。\n\n## 可复用解决流程\n\n### 步骤1：识别错误\n- 观察错误信息中是否包含 `<EnumType.VALUE: 'value'>` 格式\n- 确认枚举类型名称（如 OutputType.DIRECTORY）\n\n### 步骤2：定位代码位置\n- 搜索相关枚举类型定义，查看所有枚举值\n- 定位到抛出异常的代码，找到字典访问位置\n- 常见位置：`dict[enum_value]` 或 `dict.get(enum_value)`\n\n### 步骤3：完整性检查\n- 列出枚举的所有可能值\n- 对比字典定义，找出缺失的键\n- 检查是否存在多个字典需要更新（如本例中的styles、header_styles、text_colors等）\n\n### 步骤4：修复字典\n- 为缺失的枚举值添加字典条目\n- 参考已有条目的格式，选择合适的默认值\n- 确保所有相关字典都包含完整的枚举值映射\n\n### 步骤5：验证修复\n- 读取修改后的代码，确认所有枚举值都有定义\n- 如果可能，执行测试用例验证修复\n- 检查语法正确性\n\n## 注意事项\n1. **枚举值同步**：新增枚举值时，必须同步更新所有相关字典\n2. **默认值策略**：使用 `.get(enum_value, default)` 可以提供更好的容错性\n3. **一致性检查**：同类字典（如多个样式字典）应保持枚举值覆盖的一致性\n4. **向后兼容**：修改时保持已有条目不变\n\n## 可选步骤\n- 添加静态检查工具或脚本，在代码审查时检测枚举与字典的完整性\n- 为字典访问添加类型注解，帮助IDE识别潜在问题\n- 编写单元测试覆盖所有枚举值的使用场景",
  "scope": "global"
}