{
  "problem_type": "C函数到Rust的精确移植",
  "content": "# C函数到Rust的精确移植方法论\n\n## 问题重述\n如何将C函数精确移植到Rust，确保功能一致性，同时解决类型系统差异、内存安全问题和边界条件处理。\n\n## 可复用解决流程\n\n### 阶段1：需求分析与范围界定\n1. **识别核心功能**：明确C函数的核心目标\n2. **标记关键约束**：如Python版本兼容、性能要求、不修改核心依赖等\n3. **定位项目结构**：确定相关模块和依赖关系\n\n### 阶段2：代码分析与差异识别\n**工具组合**：\n- `read_code`：读取C源码和现有Rust实现\n- `read_symbols`：获取符号信息和依赖关系\n- 代码审查：识别类型差异、内存访问模式、边界条件\n\n**关键检查点**：\n- 类型常量定义（如TY_ARRAY等枚举值）\n- 指针操作和内存访问模式\n- 重定位/链接相关处理\n- 字节级数据操作\n\n### 阶段3：数据结构映射\n**映射策略**：\n- C指针 → Rust智能指针或引用\n- C字节数组 → Rust Vec<u8>\n- C链表 → Rust Option<Box<T>>\n- C枚举 → Rust const或enum\n\n### 阶段4：功能实现与边界处理\n**实现步骤**：\n1. 创建基础结构体映射\n2. 实现核心算法逻辑\n3. 添加边界检查和保护\n4. 处理字节对齐和填充\n5. 实现重定位/特殊数据处理\n\n### 阶段5：测试验证\n**测试类型**：\n- 基础功能测试\n- 边界值测试\n- 重定位处理测试\n- 内存安全测试\n- 回归测试（确保不破坏现有功能）\n\n## 关键注意事项\n\n1. **类型安全**：将C的弱类型检查转换为Rust的强类型系统\n2. **内存安全**：用Vec<u8>替代裸指针操作，避免越界访问\n3. **边界处理**：正确处理初始化数据长度与类型大小的差异\n4. **常量定义**：明确定义所有C中的常量，避免硬编码\n5. **模块组织**：将相关类型放在合适模块，避免重复定义\n\n## 可选步骤\n\n1. **性能优化**：使用Rust的零成本抽象特性\n2. **错误处理**：添加适当的错误处理机制\n3. **API设计**：提供更Rust风格的API接口\n4. **文档完善**：添加详细的代码注释和文档\n\n## 工具使用技巧\n\n- 使用`edit_file`进行精准修改，保留原有结构\n- 使用`execute_script`运行测试验证\n- 分步提交，确保每个修改都可回退\n- 充分利用编译器错误信息指导修复"
}