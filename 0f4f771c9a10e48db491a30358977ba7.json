{
  "problem_type": "Rust cfg 条件编译导致单元测试无法覆盖核心逻辑",
  "content": "|||\n 问题重述：\n 单元测试覆盖率低，关键业务逻辑被 #[cfg(not(test))] 或 #[cfg(test)] 保护，导致测试代码无法执行或覆盖被保护的代码分支。\n\n 可复用解决流程：\n\n 1. 代码重构策略\n    - 提取可测试的核心逻辑到独立函数，不受 cfg 保护\n    - 为被保护函数创建测试友好的包装版本\n    - 使用 trait 抽象实现，允许在测试中注入 mock 实现\n\n 2. 条件编译重构\n    - 将 cfg 保护从函数级别下沉到具体实现细节\n    - 保留核心函数签名不变，但内部逻辑可测试\n    - 创建 cfg(test) 特定的辅助函数用于测试环境\n\n 3. 测试分层策略\n    - 单元测试：测试纯逻辑函数（无 I/O、无系统调用）\n    - 集成测试：测试完整的服务器启动和运行流程\n    - 模糊测试：测试协议解析和状态机逻辑\n\n 4. 具体技术方案\n    - 将系统调用封装到独立模块，可通过 cfg 选择实现\n    - 使用依赖注入模式，在测试中提供 mock 实现\n    - 为 I/O 操作定义 trait，允许测试替换为内存实现\n\n 5. 验证标准\n    - 所有核心业务逻辑路径在单元测试中可达\n    - cfg(test) 分支两端都有测试覆盖\n    - 保持生产代码性能不受影响\n\n 注意事项：\n - 重构时要保持向后兼容性，避免影响现有集成测试\n - 测试环境配置要模拟真实场景，特别是错误处理路径\n - 注意 cfg(test) 代码不会被编译到生产环境，确保不引入依赖\n - 系统调用和 I/O 的 mock 要准确反映真实行为\n|||",
  "scope": "global"
}