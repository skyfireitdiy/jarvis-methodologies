{
  "problem_type": "C到Rust函数级TDD转译方法论",
  "content": "# C到Rust函数TDD转译方法论（验证版）\n\n## 问题重述\n将C函数按TDD方式转译为等价的Rust函数，确保语义一致性和测试完备性。\n\n## 可复用解决流程\n\n### 阶段1：需求分析\n- **工具**：read_code + read_symbols\n- **输出**：函数签名、依赖列表、控制流图\n- **关键**：识别所有依赖函数和类型别名\n\n### 阶段2：RED阶段（测试先行）\n1. 创建测试模块 `#[cfg(test)] mod tests`\n2. 设计测试用例覆盖：\n   - 空输入/边界值\n   - 正常路径\n   - 错误路径\n   - 特殊数据组合\n3. 使用模拟实现处理跨模块依赖：\n   - 在测试模块中提供模拟函数\n   - 使用条件编译区分测试/生产环境\n\n### 阶段3：GREEN阶段（最小实现）\n1. 按C逻辑逐行转译：\n   - `while(true)` → `loop`\n   - `goto` → `break/continue`\n   - 错误码 → `Result<T, E>`\n   - 指针参数 → 引用参数\n2. 保持类型安全：\n   - 使用Rust原生类型\n   - 避免裸指针除非必要\n3. 边界条件处理：\n   - 零值检查\n   - 溢出防护\n   - 内存边界验证\n\n### 阶段4：REFACTOR阶段（优化）\n1. 清理测试中的重复实现\n2. 统一依赖函数的实现位置\n3. 优化条件编译结构\n4. 完善错误处理\n\n## 注意事项\n- 禁用`todo!()`和`unimplemented!()`\n- 必须使用项目现有的错误类型（如LfsError）\n- 测试用例必须可编译通过\n- 保持与C行为的严格一致性\n\n## 工具使用顺序\n1. read_code读取C源码\n2. edit_file创建测试框架\n3. cargo test运行测试（预期失败）\n4. 迭代实现直到测试通过\n5. cargo test验证最终通过\n\n## 可选步骤\n- 性能基准测试对比\n- 内存安全检查验证\n- 与C实现的行为一致性验证"
}