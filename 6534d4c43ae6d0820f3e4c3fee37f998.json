{
  "problem_type": "Rust条件编译FFI依赖诊断",
  "content": "## 问题重述\n在 Rust 项目中，使用条件编译 (`#[cfg(feature = \"...\")]`) 链接外部 FFI 动态库时，测试失败并报错 `cannot open shared object file: No such file or directory`。常见于项目使用了可选的 feature，而这些 feature 依赖外部 C/C++ 库。\n\n## 解决流程\n\n### 第一步：诊断依赖链\n1. **查看 Cargo.toml**：\n   ```bash\n   rg '^\\w+ = \\[' idf/Cargo.toml\n   ```\n   分析目标 feature 的依赖链\n\n2. **查看 build.rs**：\n   ```bash\n   rg 'cfg\\(feature' build.rs\n   ```\n   确认哪些功能启用了外部库链接\n\n3. **查找库的使用位置**：\n   ```bash\n   rg -l 'crate::extern' src/ | rg feature\n   ```\n   确认目标模块是否直接依赖该 feature\n\n### 第二步：验证测试配置\n1. **检查测试是否需要该 feature**：\n   - 查看测试代码是否直接使用了依赖 FFI 的模块\n   - 如果测试代码只使用 Rust 代码，可能不需要该 feature\n\n2. **尝试不启用该 feature 运行测试**：\n   ```bash\n   cargo test -p idf --no-default-features --features ushell,vos\n   ```\n\n### 第三步：解决方案选择\n\n**方案 A：测试不需要该 feature**（推荐）\n- 如果目标模块的测试不依赖 FFI，只需确保 Cargo.toml 的 feature 配置正确\n- 使用默认 feature 或仅启用必要的 feature 运行测试\n\n**方案 B：需要配置外部库路径**\n- 如果测试确实需要该 feature：\n  1. 检查 `PUBSUB_LIB_PATH` 等环境变量\n  2. 在 build.rs 中找到默认库路径\n  3. 确保库文件存在或设置正确的环境变量\n\n**方案 C：Mock 外部依赖**\n- 对于无法提供外部库的测试环境：\n  - 使用条件编译 `#[cfg(test)]` 提供 mock 实现\n  - 或使用 `cfg_attr(test, ...)` 提供替代实现\n\n## 注意事项\n1. **feature 依赖分析**：理解 feature 之间的依赖关系，避免启用不必要的功能\n2. **条件编译隔离**：确保测试代码和测试模块的 feature 需求一致\n3. **FFI 库路径**：外部动态库通常需要特定的编译环境和库搜索路径\n4. **集成测试位置**：Rust 集成测试位于 `src/模块/tests/` 或项目根目录 `tests/`\n5. **覆盖率测试**：使用 `cargo llvm-cov` 时，feature 配置会影响覆盖率收集\n\n## 验证标准\n- 测试可以正常运行，无动态库加载错误\n- 测试覆盖率正常收集\n- 代码通过 clippy 检查",
  "scope": "global"
}