{
  "problem_type": "Rust测试并发和全局状态管理",
  "content": "# Rust全局状态测试隔离性验证方法论\n\n## 问题重述\nRust项目中存在全局状态（如静态变量、lazy_static!定义的全局数据）导致测试间相互影响，出现并发测试不稳定或重复运行失败的问题。\n\n## 可复用解决流程\n\n### 步骤1：识别全局状态\n使用工具识别所有全局状态定义：\n```bash\nrg -n \"static|lazy_static|GLOBAL|static mut\" src/ --type rust | head -20\n```\n\n### 步骤2：检查清理函数实现\n验证每个全局状态模块是否提供清理函数：\n- 宏定义：clear_macros()\n- Include缓存：reset_include_cache(), reset_include_next_idx()\n- 作用域：clear_scopes(), clear_typedefs()\n- 临时文件：reset_tmpfiles()\n- 其他全局状态：根据具体实现\n\n### 步骤3：验证清理函数可访问性\n确保所有清理函数都是`pub fn`公共函数：\n```bash\nrg -n \"pub fn (clear_|reset_)\" src/ --type rust\n```\n\n### 步骤4：检查测试调用清理函数\n确认每个测试都正确调用相应清理函数：\n```bash\nrg -n \"(clear_|reset_)\" src/ --type rust | grep \"test\"\n```\n\n### 步骤5：并发稳定性测试\n运行多次测试验证稳定性：\n```bash\nfor i in {1..5}; do echo \"运行第 $i 次...\"; cargo test --quiet || exit 1; done\n```\n\n### 步骤6：处理并发问题\n如果遇到测试失败，检查：\n1. Mutex是否被poisoned（使用into_inner恢复）\n2. 清理函数是否包含文件系统清理逻辑\n3. 全局状态是否完全重置\n\n## 注意事项\n- 清理函数必须在模块级别暴露为`pub fn`，不能仅在测试模块内部\n- 全局状态访问需处理Mutex::poison错误\n- 涉及文件系统的清理函数需处理文件删除失败情况\n- 频繁运行的测试应每次重置相关全局状态\n\n## 可选步骤\n- 使用`#[cfg(test)]`条件编译为测试提供专用清理接口\n- 考虑使用测试fixture模式统一清理调用\n- 对于复杂全局状态，实现事务式清理和验证"
}