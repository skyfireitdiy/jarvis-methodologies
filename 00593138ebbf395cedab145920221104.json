{
  "problem_type": "Rust全局状态并发测试修复",
  "content": "# Rust全局状态并发测试修复方法论\n\n## 问题重述\nRust项目中使用全局Mutex管理状态时出现并发测试失败，主要表现为：\n1. Mutex被poisoned导致测试panic\n2. 测试间全局状态污染\n3. 并发测试不稳定\n\n## 可复用解决流程\n\n### 1. 诊断阶段\n- 运行测试：`cargo test -- --test-threads=10`\n- 识别失败模式：panic来源、poisoned错误\n- 检查全局状态使用场景\n\n### 2. 修复阶段\n\n#### 2.1 修复全局状态访问\n```rust\n    match GLOBAL_STATE.lock() {\n    Ok(guard) => {\n        // 正常处理逻辑\n        guard.push(item);\n}\n        Err(e) => {\n        // 处理poisoned情况\n            let mut guard = e.into_inner();\n        guard.push(item);\n}\n}\n```\n\n#### 2.2 修复重置函数\n```rust\nfn reset_global_state() {\n    match GLOBAL_STATE.lock() {\n        Ok(mut guard) => {\n            // 清理逻辑（删除文件、清空集合等）\n            cleanup(&mut guard);\n            guard.clear();\n}\n        Err(e) => {\n            // 强制清理并恢复\n            let mut guard = e.into_inner();\n            cleanup(&mut guard);\n            guard.clear();\n}\n}\n}\n```\n\n#### 2.3 修复测试用例\n- 每个测试函数开头调用`reset_global_state()`\n- 使用`unwrap_or_else(|e| e.into_inner())`处理锁错误\n- 测试结束清理资源\n\n### 3. 验证阶段\n- 运行并发测试：`cargo test -- --test-threads=10`\n- 多次运行确认稳定性\n- 验证测试隔离性\n\n## 注意事项\n1. 始终处理Mutex PoisonError，不要unwrap()\n2. 测试必须重置全局状态\n3. 清理函数要处理正常和异常两种情况\n4. 使用宽松的断言避免并发竞争\n\n## 可选步骤\n- 考虑使用`parking_lot::Mutex`更好的poisoning行为\n- 考虑使用thread-local状态替代全局状态"
}