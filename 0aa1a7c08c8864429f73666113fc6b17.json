{
  "problem_type": "Rust全局状态测试隔离性问题",
  "content": "问题重述：\nRust项目中使用静态全局变量（如`Mutex`保护的集合）时，测试间共享状态导致并发测试失败，表现为断言失败、返回值不符合预期。\n\n可复用解决流程：\n1. **识别问题特征**\n   - 测试失败信息：断言失败但逻辑看似正确\n   - 失败测试：涉及全局状态的查找/存储操作\n   - 随机性：有时通过有时失败\n\n2. **定位全局状态**\n   - 使用`read_code`查找`static`、`lazy_static`、`once_cell`定义的全局变量\n   - 检查测试函数是否使用了共享的可变状态\n\n3. **分析清理机制**\n   - 查找`clear_*`、`reset_*`、`cleanup_*`等清理函数\n   - 验证清理函数是否彻底重置状态（建议使用`scopes.clear()` + 重新初始化）\n\n4. **修复隔离性问题**\n   - 在每个测试开始前调用清理函数：`#[test] fn test_xxx() { clear_state(); ... }`\n   - 改进清理函数确保完全重置：\n     ```rust\n     pub fn clear_scopes() {\n         let mut scopes = SCOPES.lock().unwrap_or_else(|e| e.into_inner());\n         scopes.clear();\n         scopes.push(Scope::new()); // 确保默认作用域\n         clear_typedefs(); // 清理相关状态\n     }\n     ```\n\n5. **验证修复效果**\n   - 使用`execute_script`运行：`cargo test -- --nocapture`\n   - 多次运行确保稳定性：`for i in {1..5}; do cargo test -q; done`\n\n注意事项：\n- 避免在测试间依赖特定执行顺序\n- 清理函数应处理poisoned锁（使用`into_inner()`）\n- 考虑使用`serial_test`crate作为替代方案\n\n可选步骤：\n- 添加调试输出：`println!(\"Scope state: {:?}\", scopes);`\n- 使用`cargo test -- --test-threads=1`验证顺序执行是否通过"
}