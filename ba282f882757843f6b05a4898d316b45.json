{
  "problem_type": "Rust全局状态测试清理",
  "content": "# Rust全局状态测试清理方法论\n\n## 问题重述\nRust测试中使用全局Lazy<Mutex<T>>或静态变量时，测试间共享状态导致污染，需要确保每个测试开始前状态干净。\n\n## 可复用解决流程\n\n### 1. 问题识别阶段\n- **工具**: cargo test\n- **检查**: 测试单独运行通过但整体运行失败\n- **症状**: 断言失败、状态残留、非确定性错误\n\n### 2. 根因定位阶段\n- **工具**: read_code + execute_script\n- **步骤**:\n  1. 检查全局状态变量定义（Lazy<Mutex<T>>或static）\n  2. 识别测试清理函数实现\n  3. 运行单个测试 vs 整体测试对比结果\n\n### 3. 修复实施阶段\n- **核心原则**: 完全重置而非仅清空集合\n- **修复模式**:\n```rust\n// ❌ 不推荐：仅清空集合\npub fn clear_scopes() {\n    let mut scopes = SCOPES.lock().unwrap();\n    scopes.clear();  // 仅清空，可能保留容量\n}\n\n// ✅ 推荐：完全重新初始化\npub fn clear_scopes() {\n    let mut scopes = SCOPES.lock().unwrap();\n    *scopes = Vec::new();  // 完全重置\n}\n```\n\n### 4. 验证阶段\n- **工具**: execute_script\n- **步骤**:\n  1. 运行单个测试确认功能正常\n  2. 运行所有相关测试确认无状态污染\n  3. 重复运行整体测试套件确保稳定性\n\n## 注意事项\n- 对于复杂状态，考虑使用Mutex::new(T::default())完全替换\n- 确保线程安全，避免死锁\n- 保持API不变以满足向后兼容要求\n- 最小化改动，避免引入新依赖\n\n## 可选步骤\n- 使用mock或测试double隔离全局状态\n- 考虑使用thread_local!作为替代方案\n- 实现drop trait确保资源正确清理"
}