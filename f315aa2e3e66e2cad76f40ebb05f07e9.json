{
  "problem_type": "Rust测试并发失败修复",
  "content": "问题重述：\nRust测试套件在并发执行时出现间歇性失败，但单独运行测试用例时通过，表明存在测试间状态污染问题。\n\n可复用解决流程：\n1. **隔离验证**\n   - 使用 `cargo test <测试名称> -- --nocapture` 单独运行失败测试\n   - 若单独运行通过，确认是并发状态污染问题\n\n2. **状态污染定位**\n   - 检查全局静态变量（如Mutex、Lazy等）的使用\n   - 验证测试清理函数（如clear_*函数）是否完全重置状态\n   - 特别注意锁处理和异常清理逻辑\n\n3. **修复策略**\n   - 确保每个测试用例的setup/teardown完全隔离\n   - 使用`match .lock() { Ok(guard) => guard, Err(poisoned) => poisoned.into_inner() }`处理锁中毒\n   - 在清理函数中重置所有相关全局状态\n\n4. **验证修复**\n   - 单独运行确认逻辑正确\n   - 并发运行确认无回归\n   - 多次运行确保稳定性\n\n注意事项：\n- 避免在测试间共享可变全局状态\n- 使用#[serial]或类似机制控制测试顺序（如果需要）\n- 清理函数应重置所有相关状态，包括标签、作用域、typedef等\n\n可选步骤：\n- 添加调试输出定位具体污染点\n- 使用临时文件隔离测试数据\n- 考虑使用once_cell的sync::Lazy而非全局变量"
}