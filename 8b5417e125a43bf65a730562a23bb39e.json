{
  "problem_type": "Rust中SA-IS算法实现流程",
  "content": "问题重述：\n需要在Rust中实现SA-IS（Suffix Array Induced Sorting）算法，保持与现有API签名兼容，实现线性时间复杂度优化，并提供完整的测试覆盖。\n\n可复用解决流程（步骤化）：\n\n1. **需求分析阶段**\n   - 确认API签名约束：fn(input: &[u8]) -> Vec<i32>\n   - 性能目标：O(n)时间复杂度，预期提升25-50%\n   - 代码约束：纯Rust安全代码，避免unsafe\n\n2. **架构设计阶段**\n   - 模块化分解：将算法分解为7个核心步骤\n   - 定义清晰的数据流和函数接口\n   - 为每个步骤创建独立的测试单元\n\n3. **实现阶段**\n   - 步骤1：实现类型分类（classify_types）\n   - 步骤2：实现桶边界计算（compute_buckets）\n   - 步骤3：实现LMS位置查找（find_lms_positions）\n   - 步骤4：实现LMS子串放置（place_lms_substrings）\n   - 步骤5：实现L型后缀诱导排序（induce_sort_l）\n   - 步骤6：实现S型后缀诱导排序（induce_sort_s）\n   - 步骤7：实现主函数sais_sort整合所有步骤\n\n4. **测试验证阶段**\n   - 基础功能测试：空输入、单字符、简单字符串\n   - 边缘情况测试：重复字符、特殊字符等\n   - 性能基准测试与现有实现对比\n\n5. **集成阶段**\n   - 验证API兼容性\n   - 执行完整测试套件\n   - 性能回归测试\n\n注意事项：\n- 所有函数参数和返回值类型必须与现有系统兼容\n- 使用Vec<i32>而不是Vec<usize>保持API一致性\n- 避免使用unsafe代码块\n- 保持算法步骤的清晰可读性\n\n可选步骤：\n- 添加内联优化属性以提高性能\n- 实现更详细的错误处理\n- 添加性能分析标记用于后续优化"
}