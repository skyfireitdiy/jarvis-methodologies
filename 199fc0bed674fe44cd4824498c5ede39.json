{
  "problem_type": "状态管理重构",
  "content": "# 状态管理重构方法论\n\n## 规则简介\n\n本方法论适用于需要管理具有\"加载\"和\"激活\"两个状态的资源的系统重构，如规则管理、配置管理、插件管理等。通过三层架构模式和渐进式重构策略，实现清晰的职责分离和向后兼容。\n\n## 你必须遵守的原则\n\n### 原则1：明确区分\"加载\"和\"激活\"状态\n\n**要求说明：**\n\n- **必须**：明确定义\"加载\"（资源读取到内存）和\"激活\"（资源生效）两个状态\n- **必须**：提供独立的接口控制加载和激活操作\n- **禁止**：混淆加载和激活状态\n- **禁止**：在加载时自动激活（除非明确需要）\n\n**实践指导：**\n\n- 使用 `load_xxx()` 方法加载资源到缓存\n- 使用 `activate_xxx()` 方法激活资源使其生效\n- 提供状态查询接口，如 `get_status()` 返回 \"active\"/\"loaded\"/\"not_loaded\"\n\n### 原则2：三层架构模式\n\n**要求说明：**\n\n- **必须**：实现缓存层、激活层、合并层三层结构\n- **必须**：每层职责单一、清晰\n- **禁止**：在一层中混合多个职责\n\n**架构设计：**\n\n1. **缓存层（_loaded_items）**：`Dict[str, Any]`\n   - 存储已加载的资源内容\n   - 避免重复读取文件或计算\n   - 支持快速访问资源内容\n\n2. **激活层（_active_items）**：`Set[str]`\n   - 记录当前生效的资源名称\n   - 支持动态激活/停用操作\n   - 提供状态查询能力\n\n3. **合并层（_merged_content）**：`str` 或 `Any`\n   - 预计算所有激活资源的合并结果\n   - 提升访问性能\n   - 避免每次重新合并\n\n### 原则3：渐进式向后兼容\n\n**要求说明：**\n\n- **必须**：保留旧接口和数据结构\n- **必须**：新旧机制并行运行\n- **禁止**：一次性破坏现有接口\n- **禁止**：在未验证前删除旧代码\n\n**兼容策略：**\n\n1. 旧接口内部调用新机制\n2. 查询时同时检查新旧状态\n3. 测试全部通过后再考虑迁移\n4. 提供清晰的迁移文档\n\n## 你必须执行的操作\n\n### 阶段1：设计和准备\n\n1. **分析现有代码**：\n   - 识别当前的状态管理方式\n   - 找出混淆加载和激活的地方\n   - 评估影响范围和依赖关系\n\n2. **设计新架构**：\n   - 定义三层结构的数据类型\n   - 设计核心接口方法签名\n   - 规划新旧机制的共存方式\n\n3. **制定验证标准**：\n   - 列出必须通过的测试\n   - 确认性能指标不能退化\n   - 定义功能验证步骤\n\n### 阶段2：实现核心功能\n\n1. **添加状态管理属性**（在 `__init__` 方法中）：\n   ```python\n   # 私有属性：状态管理\n   self._loaded_items: Dict[str, Any] = {}  # 缓存层\n   self._active_items: Set[str] = set()     # 激活层\n   self._merged_content: Any = None          # 合并层\n  \n   # 向后兼容：保留旧属性\n   self.loaded_items: Set[str] = set()\n```\n\n2. **实现核心接口方法**：\n   - `activate_item(name: str) -> bool` - 激活资源\n   - `deactivate_item(name: str) -> bool` - 停用资源\n   - `get_active_content() -> Any` - 获取合并内容\n   - `get_item_status(name: str) -> str` - 获取状态\n\n3. **实现辅助方法**：\n   - `_merge_active_items() -> None` - 合并激活项\n   - `_load_default_items() -> None` - 加载默认项\n\n### 阶段3：更新现有方法\n\n1. **重构加载方法**：\n   - 修改 `load_all_items()` 使用新机制\n   - 内部调用 `activate_item()` 而非直接操作\n   - 保持返回值和签名不变\n\n2. **更新查询方法**：\n   - 修改 `get_all_items_with_status()`\n   - 优先检查新状态（`_active_items`）\n   - 向后兼容检查旧状态（`loaded_items`）\n\n3. **渐进式迁移**：\n   - 确保所有测试通过\n   - 监控性能表现\n   - 逐步迁移调用方到新接口\n\n### 阶段4：验证和测试\n\n1. **功能验证**：\n   - 运行所有现有测试\n   - 验证新接口功能正常\n   - 手动测试激活/停用操作\n\n2. **性能验证**：\n   - 对比重构前后性能\n   - 确认无性能退化\n   - 如有下降，分析原因并优化\n\n3. **兼容性验证**：\n   - 确认旧接口仍可用\n   - 验证新旧机制结果一致\n   - 检查所有依赖方未受影响\n\n## 实践指导\n\n### 最佳实践\n\n**1. 状态转换图**：\n```\nnot_loaded → loaded → active\n     ↓         ↓        ↓\n   can       can     can\n    load    activate deactivate\n```\n\n**2. 命名约定**：\n- 缓存层：`_loaded_xxx`\n- 激活层：`_active_xxx`\n- 合并层：`_merged_xxx`\n\n**3. 接口设计**：\n- 激活/停用操作返回 `bool` 表示成功/失败\n- 状态查询返回枚举值（\"active\"/\"loaded\"/\"not_loaded\"）\n- 获取合并内容返回预计算结果\n\n### 常见错误\n\n**错误1：在激活时重复加载**\n- **问题**：每次 `activate()` 都调用 `load()`，导致性能问题\n- **解决**：先检查缓存，已加载则直接使用\n\n**错误2：忘记更新合并层**\n- **问题**：激活/停用后未调用 `_merge_active_items()`\n- **解决**：在 `activate()` 和 `deactivate()` 末尾调用合并方法\n\n**错误3：向后兼容不完整**\n- **问题**：只更新了部分查询方法\n- **解决**：全面检查所有访问状态的地方\n\n### 性能优化建议\n\n1. **预计算合并结果**：在激活/停用时更新合并层，避免每次查询时重新计算\n2. **延迟加载**：只在首次激活时加载资源内容\n3. **缓存清理**：提供 `clear_cache()` 方法释放不再需要的资源\n\n## 检查清单\n\n完成状态管理重构后，必须确认：\n\n- [ ] 三层架构已实现（缓存、激活、合并）\n- [ ] 核心接口方法已实现（activate/deactivate/get_status）\n- [ ] 现有方法已更新使用新机制\n- [ ] 所有测试通过（重构前后测试结果一致）\n- [ ] 向后兼容性已验证（旧接口仍可用）\n- [ ] 性能无明显下降（如有下降已优化）\n- [ ] 代码可读性提升（职责清晰、命名明确）\n- [ ] 文档已更新（包含架构设计和使用示例）\n- [ ] 状态转换逻辑已验证\n- [ ] 无内存泄漏（缓存正确清理）",
  "scope": "global"
}