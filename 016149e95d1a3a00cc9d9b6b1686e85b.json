{
  "problem_type": "测试用例补充",
  "content": "## 问题重述\n功能已实现但缺少测试用例，需要为现有代码补充完整的测试覆盖。\n\n## 解决流程\n\n### 第一步：分析源代码\n1. 使用 `read_code` 读取目标类的实现代码\n2. 识别所有公开方法（public methods）和关键内部方法\n3. 记录：\n   - 方法的参数和返回值\n   - 方法的主要功能\n   - 可能的边界情况和异常路径\n   - 组件间的交互关系\n\n### 第二步：列出测试需求清单\n对每个方法，列出需要测试的场景：\n1. **正常功能测试**：预期输入产生预期输出\n2. **边界条件测试**：空值、空数组、单元素等\n3. **类型覆盖测试**：所有支持的类型\n4. **交互测试**：按钮点击、用户输入等 UI 交互\n5. **集成测试**：多个方法/组件协同工作\n6. **错误处理测试**：异常情况的处理\n7. **状态变化测试**：操作后的状态变化\n\n### 第三步：设计测试用例结构\n按功能分组测试类：\n- `Test<ClassName>Basic`: 基础功能测试\n- `Test<ClassName><Feature>Feature`: 特定功能测试\n- `Test<ClassName>EdgeCases`: 边界情况测试\n- `Test<ClassName>Integration`: 集成测试\n\n### 第四步：编写测试用例\n1. 使用 pytest 框架\n2. 每个测试方法名称描述明确：`test_<场景>_<条件>_<预期>`\n3. 使用 AAA 模式：Arrange（准备）→ Act（执行）→ Assert（断言）\n4. 使用 fixtures 复用测试数据\n\n### 第五步：验证测试完整性\n1. 运行测试：`pytest tests/<path> -v`\n2. 检查覆盖率（如果可用）\n3. 确认所有新测试通过\n4. 确认所有现有测试仍通过（回归测试）\n\n### 第六步：检查预期输出\n逐条验证任务要求的预期输出：\n1. 读取测试文件确认测试用例存在\n2. 使用 grep 搜索关键词验证覆盖\n3. 运行 pytest 确认通过\n\n## 注意事项\n- 不要删除现有测试用例\n- 新增测试应该独立运行，不依赖顺序\n- 测试名称应该清晰表达测试意图\n- 对于 Textual/TUI 组件，注意测试环境的可用性\n- 模态窗口等异步操作可能需要特殊处理\n\n## 可选步骤\n- 使用 pytest-cov 生成覆盖率报告\n- 添加参数化测试减少重复代码\n- 使用 mock 隔离依赖项"
}