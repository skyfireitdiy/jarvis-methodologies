{
  "problem_type": "Rust并发原子操作竞态条件修复",
  "content": "## 问题重述\nRust中使用原子操作时，全局静态变量的竞态条件导致测试失败，表现为：\n1. fetch_add使用方式在并发下不安全\n2. 测试间全局状态污染\n3. 返回值计算逻辑错误\n\n## 可复用解决流程\n\n### 步骤1: 问题识别与定位\n- 使用 `cargo test -- --test-threads=1` 运行测试，确认是否并行执行导致\n- 检查全局静态变量（如 `static DEPTH: AtomicUsize`）的使用方式\n- 验证 `fetch_add` 使用模式是否正确\n\n### 步骤2: 修复原子操作逻辑\n1. **错误的模式**：`let new = old.fetch_add(1) + 1`\n2. **正确的模式**：直接使用返回值或预计算值\n3. **代码修复**：\n```rust\n// 错误\npub fn push() -> usize {\n    DEPTH.fetch_add(1, Ordering::Relaxed) + 1\n}\n\n// 正确\npub fn push() -> usize {\n    DEPTH.fetch_add(1, Ordering::SeqCst)\n}\n```\n\n### 步骤3: 测试隔离性修复\n在测试模块中添加状态重置函数：\n```rust\n#[cfg(test)]\nfn reset_depth() {\n    DEPTH.store(0, Ordering::SeqCst);\n}\n\n#[test]\nfn test_push_initial() {\n    reset_depth(); // 每个测试前重置\n    assert_eq!(push(), 1);\n    assert_eq!(DEPTH.load(Ordering::SeqCst), 1);\n}\n```\n\n### 步骤4: 并发验证\n- 运行 `cargo test` 验证并行测试\n- 运行 `cargo test -- --test-threads=1` 验证串行测试\n- 使用 `cargo test push -- --nocapture` 查看详细输出\n\n## 注意事项\n1. 使用 `Ordering::SeqCst` 而非 `Relaxed` 避免内存重排序\n2. 全局变量必须在测试间显式重置\n3. 考虑使用 `std::sync::OnceLock` 或 `thread_local!` 替代全局变量\n4. 测试并发代码时，尽量使用确定性测试而非依赖全局状态\n\n## 可选步骤\n- 使用 `parking_lot::Mutex` 替代原子操作（复杂场景）\n- 实现自定义测试运行器以自动化状态重置\n- 使用属性宏自动注入状态重置代码"
}