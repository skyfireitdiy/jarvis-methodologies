{
  "problem_type": "rust-panic-to-result-fix",
  "content": "=== Rust panic到Result错误处理修复方法论 ===\n\n**问题重述**\n将Rust函数中的panic!调用改为Result<T, E>错误处理机制，同时保持功能不变，确保测试通过。\n\n**可复用解决流程**\n\n1. **定位panic源**\n   - 使用 `rg 'panic!' src/` 搜索所有panic调用\n   - 识别与当前问题相关的panic位置\n   - 分析panic触发条件和上下文\n\n2. **修改函数签名**\n   - 将函数返回类型从`T`改为`Result<T, String>`（或适当的错误类型）\n   - 确保所有返回路径都返回Ok或Err\n\n3. **替换panic调用**\n   - 将`panic!(\"error message\")`改为`return Err(\"error message\".to_string())`\n   - 保持错误消息语义不变\n\n4. **更新调用者**\n   - 使用`rg 'function_name\\('`查找所有调用点\n   - 为每个调用添加Result处理：\n     - 使用`?`运算符传播错误\n     - 或使用`match`/`if let`显式处理\n\n5. **更新测试用例**\n   - 移除`#[should_panic]`属性\n   - 移除`expected`参数\n   - 改为断言Result:\n     ```rust\n     let result = function_call(...);\n     assert!(result.is_err());\n     assert_eq!(result.unwrap_err(), \"expected error\");\n     ```\n   - **重要**：不要先调用`.unwrap()`再断言错误\n\n6. **验证修复**\n   - 运行`cargo test`确保所有测试通过\n   - 运行`rg 'panic!'`确认相关panic已移除\n   - 检查错误信息是否符合预期\n\n**注意事项**\n- 保持错误消息文本不变以保持向后兼容\n- 考虑错误类型的粒度：使用String简单场景，复杂场景考虑自定义错误类型\n- 避免引入新的panic\n- 对于公共API，考虑错误类型的稳定性\n\n**可选步骤**\n- 使用`thiserror`或`anyhow`改善错误处理\n- 添加更详细的错误上下文\n- 实现From trait用于错误转换"
}