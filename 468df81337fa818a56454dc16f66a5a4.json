{
  "problem_type": "C到Rust UTF-8函数TDD转译",
  "content": "# UTF-8相关函数C到Rust转译方法论\n\n## 问题重述\n将C语言的UTF-8处理函数（如decode_utf8、encode_utf8）转译为Rust实现，使用TDD方法确保语义等价。\n\n## 可复用解决流程\n\n### 阶段1：源码分析\n1. **使用read_symbols**获取C函数符号的完整信息\n2. **使用read_code**读取C源码，重点关注：\n   - 字节操作模式（位运算、掩码）\n   - 错误处理机制（error_at等）\n   - 边界条件处理\n\n### 阶段2：边界条件映射\n将C的UTF-8边界条件映射到Rust测试：\n- **ASCII范围**：0x00-0x7F\n- **2字节序列**：0xC0-0xDF前缀 + 0x80-0xBF延续\n- **3字节序列**：0xE0-0xEF前缀 + 2个延续字节\n- **4字节序列**：0xF0-0xF7前缀 + 3个延续字节\n- **错误场景**：\n  - 过编码（overlong encoding）\n  - 无效起始字节\n  - 无效延续字节\n  - 代理码点（0xD800-0xDFFF）\n  - 超出Unicode范围（>0x10FFFF）\n\n### 阶段3：TDD测试设计\n设计测试用例覆盖：\n1. **有效序列测试**：边界值、典型值\n2. **无效序列测试**：每类错误至少一个测试\n3. **边缘情况**：空输入、不完整序列\n\n### 阶段4：实现策略\n- **位运算转换**：C的位运算直接对应Rust的位运算\n- **错误处理**：将C的error_at转换为Result<String, E>\n- **内存管理**：利用Rust的切片安全性和自动内存管理\n\n### 阶段5：验证与优化\n1. **运行cargo test**验证所有测试通过\n2. **检查overlong encoding检测**（C通常会检测）\n3. **验证代理码点处理**\n\n## 注意事项\n- UTF-8解码必须严格遵循RFC 3629规范\n- Rust的std::str::from_utf8可作为参考，但需保持C语义\n- 过编码检测是C实现的关键特性，必须保留\n- 错误消息应保持与C实现语义一致\n\n## 可选步骤\n- 性能基准测试（对比C实现）\n- Unicode规范化处理（如果C实现支持）\n- 与现有Rust生态的集成适配"
}