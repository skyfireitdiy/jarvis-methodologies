{
  "problem_type": "task_verification",
  "content": "## 任务验证方法论\n\n### 问题重述\n如何系统化地验证任务是否真正完成，确保所有预期输出条目都已实现且符合要求。\n\n### 可复用解决流程\n\n**步骤1：解析预期输出**\n- 将任务描述中的\"预期输出\"解析为逐条可验证的条目\n- 按照换行、编号（1)、2)、3)）或 markdown 列表进行切分\n- 每条条目应该是具体的、可检查的交付物（如文件、函数、接口等）\n\n**步骤2：验证文件存在性**\n- 使用 execute_script 执行 ls 命令检查关键文件是否存在\n- 示例：ls -la path/to/file.py\n\n**步骤3：读取代码验证实现**\n- 使用 read_tool 读取目标文件内容\n- 检查每一条预期输出对应的实现是否存在：\n  - 文件是否存在？\n  - 函数是否定义？\n  - 接口是否实现？\n  - 配置是否正确（如 CORS、依赖注入等）？\n- 检查代码是否符合约束条件（如禁止使用外部模板引擎等）\n\n**步骤4：执行静态质量检查**\n- 使用 ruff 检查代码风格和潜在问题：ruff check file.py\n- 使用 mypy 检查类型注解：mypy file.py\n- 如果有测试，运行测试验证功能\n\n**步骤5：汇总验证结果**\n- 对每条预期输出标记 PASSED/FAILED\n- 说明失败原因（如有）\n- 仅在所有预期输出条目都通过时，整体判定为 PASSED\n\n### 注意事项\n1. **只验证任务明确要求的产物**：不要检查无关的项目（如整体项目编译、无关测试等）\n2. **基于实际验证结果**：不能推测或假设，必须使用 read_code 和 execute_script 实际检查\n3. **禁止修复行为**：验证阶段只检查，不修改代码，可以提供修复建议\n4. **关注具体交付物**：重点检查任务描述中明确提到的文件、函数、接口等\n\n### 可选步骤\n- 如需验证 CLI 集成，检查相关 CLI 文件（如 cli.py）中的实现\n- 如需验证前端界面，可以使用浏览器或 curl 测试接口响应\n- 对于复杂的功能，可以编写临时测试脚本验证行为"
}