{
  "problem_type": "Rust测试间歇性失败修复",
  "content": "# Rust测试间歇性失败修复方法论\n\n## 问题重述\n当Rust测试出现以下情况时：\n- 单独运行测试通过，但完整测试套件失败\n- 测试断言失败（如找不到预期输出）\n- 出现内存错误（如double free）\n\n## 可复用解决流程\n\n### 步骤1：问题确认\n1. 运行单个测试验证：`cargo test <模块>::<测试名> -- --nocapture`\n2. 运行完整测试套件：`cargo test -- --nocapture`\n3. 多次运行确认问题稳定性\n\n### 步骤2：状态污染排查\n1. **检查全局状态**：\n   - 查看是否有`static mut`变量\n   - 确认测试间的状态清理（`setup/teardown`）\n   - 验证`#[cfg(test)]`模块中的初始化逻辑\n\n2. **使用工具定位**：\n   - `read_code`工具读取测试用例实现\n   - 检查测试断言的期望输出与实际输出的差异\n   - 使用`execute_script`运行调试脚本查看实际输出\n\n### 步骤3：修复策略\n1. **状态隔离**：\n   - 确保每个测试有独立的测试数据\n   - 在`setup_context()`中正确重置全局状态\n   - 避免测试间的共享可变状态\n\n2. **断言匹配**：\n   - 验证测试期望的标签/格式与代码实现一致\n   - 检查字符串包含匹配是否过于严格\n\n### 步骤4：验证修复\n1. 运行完整测试套件验证所有测试通过\n2. 运行特定模块测试确保无回归\n3. 运行Clippy检查：`cargo clippy -- -D warnings`\n\n## 注意事项\n- 不要急于修改代码，先确认问题是否稳定重现\n- 注意并发测试可能导致的状态竞争\n- 临时调试文件（如test_debug.rs）需在修复后清理\n- 保持最小改动原则，避免不必要的重构\n\n## 可选步骤\n- 添加详细调试输出定位问题\n- 使用`RUST_BACKTRACE=1`查看完整堆栈\n- 在CI环境中验证修复效果"
}