{
  "problem_type": "C函数到Rust的TDD转译-get_struct_member",
  "content": "## C结构体成员查找函数的Rust TDD转译方法论\n\n### 问题重述\n将C的结构体成员查找函数（如get_struct_member）转译为Rust实现，需保持行为完全一致，包括匿名结构体/联合体的递归查找语义。\n\n### 可复用解决流程\n\n#### Phase 1: 需求分析\n1. **工具**: read_code + read_symbols\n2. **步骤**:\n   - 读取C源函数完整逻辑\n   - 分析Type/Member数据结构\n   - 识别匿名结构体处理逻辑\n   - 记录边界条件（空名称、递归深度等）\n\n#### Phase 2: Red阶段 - 测试设计\n1. **测试类型**: \n   - 基本功能: 普通成员查找\n   - 边界情况: 空结构体、空名称、不存在成员\n   - 递归场景: 匿名结构体嵌套查找\n   - 错误路径: 类型不匹配、名称不匹配\n\n2. **测试结构**:\n   ```rust\n   #[test]\n   fn test_get_struct_member_xxx() {\n       // 构建测试结构体\n       let mut ty = Type::struct_type();\n       // ... 添加成员数据\n       \n       // 断言验证\n       assert_eq!(ty.get_struct_member(\"target\"), Some(expected));\n   }\n   ```\n\n#### Phase 3: Green阶段 - 实现转译\n1. **数据结构转换**:\n   - C链表(next指针) → Rust Vec<Member>\n   - C字符串比较 → Rust字符串切片比较\n   - C空指针 → Rust Option\n\n2. **核心逻辑映射**:\n   ```rust\n   // C: if ((mem->ty->kind == TY_STRUCT || mem->ty->kind == TY_UNION) && !mem->name)\n   matches!(member.ty.kind, TypeKind::Struct | TypeKind::Union) && member.name.is_none()\n   \n   // C: 递归调用get_struct_member\n   member.ty.get_struct_member(name)\n   ```\n\n#### Phase 4: 编译修复\n1. **常见问题**:\n   - 模块名冲突(`type`关键字) → 使用`r#type`\n   - 字段缺失 → 补充name字段到所有Member实例\n   - 导入路径更新 → 调整use声明\n\n2. **批量修复命令**:\n   ```bash\n   sed -i 's/next: None,/next: None,\\n                name: None,/g' 目标文件\n   ```\n\n#### Phase 5: 验证阶段\n1. **测试命令**:\n   ```bash\n   cargo test test_get_struct_member\n   ```\n\n2. **验证要点**:\n   - 所有测试用例通过\n   - 匿名结构体查找深度正确\n   - 边界条件处理完整\n\n### 注意事项\n- 保持option语义：C的NULL → Rust的None\n- 字符串比较：C的strncmp → Rust的==运算符\n- 递归边界：防止栈溢出（本例中C代码无此问题）\n- 数据结构一致性：所有Member实例必须包含name字段\n\n### 可选增强\n- 添加性能基准测试对比C/Rust实现\n- 支持更复杂的匿名结构体模式匹配"
}