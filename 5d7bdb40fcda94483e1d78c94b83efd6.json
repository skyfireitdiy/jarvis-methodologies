{
  "problem_type": "Rust并发测试状态共享问题修复",
  "content": "## 问题重述\nRust并发测试时，由于测试运行器并行执行测试用例，共享静态变量的状态会导致测试断言失败，特别是验证序列行为或计数器递增的测试。\n\n## 可复用解决流程\n\n### 步骤1：问题识别\n- 运行`cargo test`确认失败模式\n- 检查是否涉及静态变量或全局状态\n- 验证失败是否因并发执行导致状态不一致\n\n### 步骤2：分析测试逻辑\n- 使用`read_code`查看测试用例实现\n- 识别绝对值依赖的断言\n- 确定测试的核心验证意图（连续性vs绝对值）\n\n### 步骤3：设计修复方案\n- **选项A**：改为验证相对行为（连续性、增量关系）\n- **选项B**：使用测试隔离（如`std::sync::Mutex`）\n- **选项C**：重置状态（如测试前后清理静态变量）\n- **优先选择**：选项A（最小侵入性）\n\n### 步骤4：实施修复\n- 使用`edit_file`修改测试用例\n- 保持被测代码不变\n- 将绝对断言改为相对验证\n\n### 步骤5：验证修复\n- 运行`cargo test -- --nocapture`\n- 多次运行验证稳定性\n- 检查是否有回归问题\n\n## 注意事项\n- **禁止**：修改被测函数的业务逻辑\n- **优先**：最小化修改范围\n- **验证**：确保修复后在并发环境下稳定通过\n\n## 代码模式示例\n\n**问题模式**：\n```rust\n#[test]\nfn test_counter() {\n    let start = next_count();\n    assert_eq!(next_count(), start + 1); // 并发下可能失败\n}\n```\n\n**修复模式**：\n```rust\n#[test]\nfn test_counter() {\n    let start = next_count();\n    let values: Vec<_> = (0..5).map(|_| next_count()).collect();\n   \n    // 验证连续性而非绝对值\n    for i in 1..values.len() {\n        assert_eq!(values[i], values[i-1] + 1);\n}\n    assert_eq!(values.last().unwrap() - start, 5);\n}\n```"
}