{
  "problem_type": "C到Rust代码重构：vector转链表实现",
  "content": "问题重述：将C风格的边遍历边构建链表操作移植到Rust，避免使用vector中间收集，保持API兼容性\n\n可复用解决流程：\n1. 代码分析阶段\n   - 使用`read_code`定位目标函数，理解原始vector使用模式\n   - 确认函数签名保持不变的要求\n   - 分析链表结构定义（通常使用Option<Box<T>>）\n\n2. 重构实现阶段\n   - 创建head和current指针：let mut head = None; let mut current = &mut head;\n   - 使用std::mem::replace处理输入token的所有权转移\n   - 实现边遍历边构建：while let Some(mut boxed_token) = next_ptr { ... }\n   - 每个token创建新节点：Box::new(Token { ... next: None })\n   - 链表连接：*current = Some(new_token); current = &mut current.as_mut().unwrap().next;\n\n3. 边界处理\n   - 空参数检查：立即遇到终止符时的特殊处理\n   - EOF处理：使用panic!(\"premature end of input\")匹配C行为\n   - 结果包装：MacroArg { tok: if has_tokens { head } else { None } }\n\n4. 验证阶段\n   - 运行`cargo check`确保编译通过\n   - 确认无vector相关代码（Vec, vec!, push等）\n   - 验证函数签名未改变\n   - 运行现有测试确保功能一致性\n\n注意事项：\n- 使用Box::new创建新节点避免生命周期问题\n- 通过.take()方法安全转移next指针所有权\n- 保持原有错误处理行为（如panic）\n- 避免不必要的内存分配\n\n适用场景：\n- C代码移植到Rust时保持原有内存模式\n- 需要避免中间集合分配的性能敏感场景\n- 需要保持API兼容的重构项目"
}