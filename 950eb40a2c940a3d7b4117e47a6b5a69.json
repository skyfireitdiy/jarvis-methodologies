{
  "problem_type": "C到Rust字符串处理转译",
  "content": "# C到Rust字符串处理转译方法论\n\n## 问题重述\n将C语言中处理字符串字面量合并的复杂逻辑（如`join_adjacent_string_literals`）转译为等效的Rust实现，需解决：\n1. 内存管理差异（手动→自动）\n2. 借用检查器限制\n3. 类型转换语义保持\n4. 测试覆盖率验证\n\n## 可复用解决流程\n\n### 阶段1：语义分析\n1. 使用`read_code`读取C源码实现\n2. 识别核心逻辑阶段：类型检查→转换→合并\n3. 标记关键差异点：\n   - C的指针操作 vs Rust的借用检查\n   - 临时内存分配方式\n   - 错误处理模式\n\n### 阶段2：Rust适配设计\n1. **所有权策略**：\n   - 使用单次遍历避免嵌套可变借用\n   - 提前计算合并范围，减少重复遍历\n2. **类型系统映射**：\n   - C的`char*` → Rust的`Vec<u8>` + `String`\n   - C的枚举 → Rust的`enum StringKind`\n3. **错误处理**：\n   - C的`error_tok()` → Rust的`panic!`（测试环境）\n\n### 阶段3：实现步骤\n1. **基础结构**：\n   ```rust\n   #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n   pub enum StringKind { StrNone, StrUtf16, StrUtf32 }\n   ```\n\n2. **核心算法**：\n   - 单次遍历同时完成类型检查和转换判断\n   - 延迟更新字符串内容直到类型统一\n   - 批量处理相邻字符串合并\n\n3. **边界处理**：\n   - 空链表快速返回\n   - 单字符串无操作\n   - 类型不匹配的提前报错\n\n### 阶段4：测试验证\n1. **单元测试**：\n   - 基础合并：`\"a\" \"b\"` → `\"ab\"`\n   - 类型转换：`\"a\" L\"b\"` → `L\"ab\"`\n   - 错误场景：`L\"a\" U\"b\"` → panic\n2. **集成验证**：\n   - 运行`cargo test -- --nocapture`\n   - 检查回归测试（272/272通过）\n\n### 注意事项\n1. **借用检查器陷阱**：\n   - 避免`&mut`的多次借用\n   - 使用`take()`转移所有权\n   - 临时变量提前绑定生命周期\n\n2. **类型转换实现**：\n   - 普通字符串内容无需重新编码（UTF-8→UTF-16/32已在tokenize阶段处理）\n   - 仅更新字符串标识前缀（L\"/U\"）\n\n3. **性能优化**：\n   - 单次遍历优于两次遍历\n   - 预计算合并长度减少内存重分配\n\n### 可选步骤\n- 添加性能基准测试（`cargo bench`）\n- 实现增量解析支持\n- 支持更多字符串前缀（如u8\"\"）"
}