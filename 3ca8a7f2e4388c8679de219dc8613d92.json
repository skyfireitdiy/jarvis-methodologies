{
  "problem_type": "C到Rust代码行为移植",
  "content": "## 问题重述\n将C语言的字符处理函数移植到Rust，要求保持100%行为一致性，包括：\n- 字符范围检查逻辑\n- 返回值语义\n- 边界条件处理\n\n## 可复用解决流程\n\n### 步骤1：原始代码分析\n使用工具：`read_code` + 人工分析\n- 提取原始C实现的核心逻辑\n- 识别关键数据结构（如范围数组）\n- 记录特殊边界处理\n\n### 步骤2：行为映射表\n创建对照表：\n| C概念 | Rust等效实现 | 注意事项 |\n|-------|--------------|----------|\n| `uint32_t` | `u32` | 确保无符号 |\n| `static uint32_t[]` | `static &[u32]` | 使用`u32::MAX`替代`-1` |\n| `while循环` | `while循环`或迭代器 | 保持索引计算一致 |\n\n### 步骤3：最小化重构\n使用工具：`rewrite_file`分阶段修改\n1. 先添加辅助函数（如`in_range`）\n2. 再重构主函数，保持API不变\n3. 每步验证构建通过\n\n### 步骤4：验证策略\n- 保留下游兼容性：确保所有调用点无需修改\n- 边界测试：针对范围边界值增加测试\n- 性能验证：确认静态数组无运行时开销\n\n### 注意事项\n1. **字符编码陷阱**：C的`char`可能为`signed`，Rust的`u8`始终为无符号\n2. **哨兵值处理**：C用`-1`结束数组，Rust用`u32::MAX`\n3. **静态生命周期**：Rust的`static`必须在编译时可确定\n4. **注释对齐**：保持中文注释风格一致\n\n### 可选步骤\n当涉及复杂算法时：\n- 先用`execute_script`运行原始C代码生成测试向量\n- 用相同测试向量验证Rust实现\n- 考虑使用`proptest`进行属性测试"
}