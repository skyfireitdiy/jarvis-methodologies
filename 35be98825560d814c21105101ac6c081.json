{
  "problem_type": "SA-IS算法实现与验证",
  "content": "# SA-IS算法实现与验证方法论\n\n## 问题重述\n需要基于SA-IS算法理论，创建完整且高效的后缀数组构造实现，替换现有的O(n log n)算法，要求保持API兼容性。\n\n## 可复用解决流程\n\n### 阶段1：算法理解与分解\n1. **理论准备**：查阅SA-IS原始论文，理解线性时间复杂度原理\n2. **模块分解**：\n   - L/S类型分类模块\n   - 桶排序预处理\n   - LMS子串识别\n   - 诱导排序主逻辑\n   - 递归处理缩减问题\n\n### 阶段2：代码实现\n1. **API设计**：保持fn(&[u8]) -> Vec<i32>签名不变\n2. **安全约束**：使用纯Rust安全代码，避免unsafe\n3. **模块化实现**：\n   ```rust\n   // 核心模块函数签名\n   classify_types(input: &[u8]) -> Vec<bool>       // L/S类型分类\n   compute_buckets(input: &[u8], k: usize) -> (Vec<usize>, Vec<usize>)  // 桶排序预处理\n   induce_sort_l/s()                              // 诱导排序\n   create_reduced_problem()                       // 递归处理\n   ```\n\n### 阶段3：验证流程\n1. **单元测试设计**：\n   - 空输入边界测试\n   - 单字符测试\n   - 已知结果验证（如\"banana\" -> [5,3,1,0,4,2]）\n   - 随机数据正确性验证\n2. **性能验证**：\n   - 与现有算法性能基准对比\n   - 大文件处理测试\n3. **兼容性验证**：\n   - API签名一致性检查\n   - 调用方无需修改验证\n\n### 阶段4：集成部署\n1. **渐进替换**：保留原有算法作为回退\n2. **性能监控**：收集实际运行数据\n3. **A/B测试**：灰度发布验证稳定性\n\n## 注意事项\n- 特别注意类型系统边界（字节序列 vs 字符串）\n- 内存使用优化（避免过度分配）\n- 递归深度控制（防止栈溢出）\n- 测试用例需覆盖边界情况\n\n## 可选步骤\n- 添加SIMD优化版本\n- 实现并行处理支持\n- 添加缓存友好的数据结构优化"
}