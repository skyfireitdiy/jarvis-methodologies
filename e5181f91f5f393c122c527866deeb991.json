{
  "problem_type": "Rust测试失败修复方法",
  "content": "# Rust测试失败修复方法论\n\n## 问题重述\n当Rust测试套件中出现测试失败时，需要快速定位问题并修复，同时确保不引入回归。\n\n## 可复用解决流程\n\n### 1. 问题识别阶段\n- 运行测试获取失败信息：`cargo test -- --nocapture`\n- 识别失败测试用例名称和断言信息\n- 检查是否为预期行为（如 should panic 测试）\n\n### 2. 问题定位阶段\n- 使用调试输出：在关键函数添加 `println!()` 或 `dbg!()` 输出\n- 读取相关代码：使用 `read_code` 工具获取函数实现\n- 分析测试用例：理解测试的预期行为和实际行为差异\n\n### 3. 修复实施阶段\n- **最小改动原则**：只修改必要的代码逻辑\n- **保持兼容性**：确保修复不破坏现有功能\n- **添加注释**：解释特殊处理的原因\n\n### 4. 验证阶段\n- 单独运行失败测试：`cargo test test_name -- --nocapture`\n- 运行完整测试套件确保无回归\n- 检查编译警告：`cargo check --message-format=short`\n\n### 5. 特殊场景处理\n- **边界条件**：如本例中的特定字节范围检查\n- **类型特殊处理**：针对不同类型（float vs double）的差异化逻辑\n- **测试用例理解**：准确理解测试意图，避免\"修复\"正确行为\n\n## 注意事项\n1. 不要假设测试失败一定是代码问题，可能是测试用例本身需要调整\n2. 对于复杂逻辑，优先添加调试信息而非盲目修改\n3. 修复后必须验证所有相关测试通过\n4. 保留特殊处理的注释，说明为何需要与标准逻辑不同的处理\n\n## 可选步骤\n- 使用 `git bisect` 找出引入问题的提交\n- 添加更多边界测试用例\n- 考虑重构复杂逻辑以提高可维护性"
}