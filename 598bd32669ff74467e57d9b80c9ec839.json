{
  "problem_type": "Rust unwrap错误处理修复",
  "content": "# Rust unwrap错误处理修复方法论\n\n## 问题重述\n在Rust代码中发现大量使用unwrap()的错误处理，根据安全分析报告需要改进错误处理机制，提高代码健壮性。\n\n## 可复用解决流程\n\n### 步骤1: 识别问题位置\n```bash\n# 查找所有.unwrap()调用\nrg '\\\\.unwrap\\\\(\\\\)' --type rust\n\n# 或查找特定模式的错误处理\nrg 'lock\\\\(\\\\)\\\\.unwrap\\\\(\\\\)' --type rust\n```\n\n### 步骤2: 分析上下文\n- 使用read_code工具读取相关文件和行号\n- 判断unwrap()使用的合理性：\n  - 测试代码：可接受，但建议改为expect()加说明\n  - 生产代码：必须改进\n- 对于Mutex锁：\n  - 线程池核心代码：中毒panic是合理行为\n  - 一般业务代码：考虑错误处理策略\n\n### 步骤3: 实施修复\n1. **Mutex.lock().unwrap()场景**：\n   ```rust\n   // 前：lock().unwrap()\n   let guard = mutex.lock().expect(\"lock_name lock poisoned\");\n   // 后：lock().expect()\n   let guard = mutex.lock().expect(\"idle_list lock poisoned\");\n```\n\n2. **错误信息格式**：\n   - 格式：`\"{资源名} lock poisoned\"`\n   - 必须清晰说明锁保护的资源用途\n\n### 步骤4: 验证修复\n```bash\n# 检查具体行号修复情况\nread_code --files '[{\\\"path\\\": \\\"src/file.rs\\\", \\\"start_line\\\": 30, \\\"end_line\\\": 80}]'\n\n# 确保编译通过\ncargo check -p <package_name>\n```\n\n## 注意事项\n1. 不要改变锁逻辑，仅改进错误处理\n2. 线程池核心同步代码中，Mutex中毒意味着程序状态损坏，panic是合理行为\n3. 保持向后兼容性\n4. expect()信息要具体、有意义\n\n## 可选步骤\n- 对于非关键路径，可以考虑返回Result而非panic\n- 添加自动化测试验证修复效果\n- 在团队规范中明确expect()的使用标准"
}