{
  "problem_type": "Rust不安全代码内存错误修复",
  "content": "# Rust不安全代码内存错误修复方法论\n\n## 问题重述\n解决Rust项目中C转译代码或unsafe块导致的内存错误（double free, invalid pointer, SIGABRT/SIGSEGV）\n\n## 可复用解决流程\n\n### 阶段1：错误定位\n1. **运行测试验证**\n   - `cargo test` 确认错误表现\n   - 使用Valgrind检测：`valgrind --tool=memcheck cargo test`\n\n2. **精确定位**\n   - 使用read_code读取报错相关文件\n   - 重点检查unsafe块、指针操作、内存分配/释放\n\n### 阶段2：代码分析\n1. **边界检查审查**\n   - 数组索引：确认所有数组访问都有边界检查\n   - 指针运算：验证指针偏移不越界\n   - 内存对齐：确保结构体内存布局正确\n\n2. **内存管理检查**\n   - 分配/释放匹配：每次malloc有对应free\n   - 所有权清晰：避免重复释放或悬挂指针\n   - Drop trait实现：为包含原始指针的结构体实现Drop\n\n### 阶段3：实施修复\n1. **添加边界保护**\n   - 在数组访问前添加索引范围检查\n   - 使用Rust的assert!或if条件保护\n   - 保持原有逻辑不变性\n\n2. **内存安全化**\n   - 将裸指针包装为Box/Rc等智能指针\n   - 为结构体实现Drop trait清理资源\n   - 使用std::ptr::drop_in_place安全释放\n\n### 阶段4：验证修复\n1. **测试验证**\n   - `cargo test` 通过所有测试\n   - Valgrind无内存错误报告\n   - 运行sanitizer测试：`RUSTFLAGS=\\\"-Z sanitizer=address\\\" cargo test`\n\n## 注意事项\n- 最小化修改：仅修改必要代码，避免重构\n- 保持接口兼容：不破坏现有API\n- 添加清晰注释：说明unsafe代码的安全假设\n- 创建测试验证：为修复添加回归测试\n\n## 可选步骤\n- 使用`cargo miri`进行更严格的未定义行为检测\n- 添加内存使用监控，检测内存泄漏\n- 考虑用安全抽象逐步替换unsafe代码"
}