{
  "problem_type": "C到Rust移植中的作用域和标签查找实现",
  "content": "问题重述：\n将C语言的作用域和标签查找功能移植到Rust时，常见测试失败包括：\n1. 作用域嵌套查找逻辑错误\n2. 标签查找范围不正确（应只查当前作用域却查了外层）\n3. 作用域初始数量不符合预期\n4. 全局状态管理不当导致测试污染\n\n可复用解决流程：\n1. **理解原始C实现**：分析C代码的作用域栈管理和查找算法\n2. **映射到Rust结构**：\n   - Vec<Scope>替代C的链表式作用域栈\n   - HashMap<String, Type>存储标签定义\n   - 使用Rc/Arc处理共享所有权（如需）\n\n3. **实现查找逻辑**：\n   - find_tag应只查找当前作用域（除非明确要求向上查找）\n   - 区分标签查找和typedef查找的不同规则\n   - 实现push_scope/pop_scope的正确配对\n\n4. **状态初始化**：\n   ```rust\n   impl Default for ScopeManager {\n       fn default() -> Self {\n           Self {\n               scopes: vec![Scope::new()], // 确保初始为1个默认作用域\n               // 其他字段...\n   }\n   }\n   }\n   ```\n\n5. **测试验证**：\n   - test_find_tag_nested_scopes：验证嵌套作用域中标签不可见\n   - test_push_tag_scope_multiple_scopes：验证初始作用域数量\n   - test_push_tag_scope_normal：验证基本作用域操作\n\n注意事项：\n- C的自动变量作用域规则与Rust不同，需明确边界\n- 确保MutexGuard在测试后正确释放（使用drop或作用域限制）\n- 考虑使用thread_local!避免全局状态污染\n- 用Option<Type>而非空指针表示查找失败\n\n可选步骤：\n- 添加作用域调试信息（文件名、行号）\n- 实现作用域可视化工具帮助调试\n- 使用property-based testing验证查找不变量"
}