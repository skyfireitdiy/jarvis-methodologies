{
  "problem_type": "rust_build_error_fix",
  "content": "# Rust构建错误修复方法论\n\n## 问题重述\n解决Rust项目编译/构建阶段的语法错误、依赖错误和作用域问题。\n\n## 可复用解决流程\n\n### 阶段1：错误识别\n1. **定位错误位置**：使用`cargo check`或`cargo build`获取精确错误信息\n2. **分析错误类型**：\n   - 语法错误（括号不匹配、缺少分号等）\n   - 作用域错误（函数/变量未找到）\n   - 配置错误（cfg条件编译问题）\n\n### 阶段2：结构验证\n1. **使用grep确认结构**：\n   ```bash\n   grep -n \"mod tests\" src/file.rs  # 确认模块边界\n   grep -n \"fn function_name\" src/file.rs  # 确认函数位置\n   ```\n2. **检查作用域隔离**：\n   - 测试模块([#cfg(test)])内的函数不能被外部调用\n   - 模块级函数必须在#[cfg(test)]之外定义\n\n### 阶段3：修复策略\n1. **括号匹配**：\n   - 使用vim/emacs的括号高亮或`grep -n '{' '}'`快速定位\n   - 删除多余的闭合括号\n\n2. **依赖问题**：\n   - 将测试专用函数重构为模块级实现\n   - 使用简化逻辑替代复杂依赖\n   - 保持API签名不变\n\n3. **文档注释**：\n   - 移除孤立的文档注释（///）\n   - 确保每个文档注释都有对应的函数/结构体\n\n### 阶段4：验证\n1. **分层验证**：\n   - `cargo check` - 基础语法\n   - `cargo build --tests` - 包含测试\n   - `cargo test` - 功能验证\n\n## 注意事项\n- 避免在模块级函数中调用#[cfg(test)]限定的函数\n- 重构时保持原有API签名不变\n- 优先简化实现而非复杂重构\n- 每次修改后都要验证构建状态\n\n## 可选步骤\n- 使用`cargo clippy`获取额外建议\n- 添加单元测试验证修复效果\n- 记录重构决策到代码注释"
}