{
  "problem_type": "FFI unsafe代码安全修复",
  "content": "问题重述：修复FFI代码中的unsafe安全问题，特别是空指针解引用风险\n\n可复用解决流程：\n1. 识别阶段\n   - 使用代码分析工具或人工检查，定位所有FFI调用点\n   - 标记涉及原始指针操作的unsafe代码块\n   - 识别第17、24、29行这类关键风险点\n\n2. 修复阶段\n   - 空指针检查：对所有FFI返回的原始指针添加.is_null()检查\n   - SAFETY文档：为每个unsafe块添加详细的安全前提注释\n   - 类型设计：考虑使用Option<T>包装可能失败的FFI调用结果\n   - 接口兼容：保持FFI接口签名不变，通过包装类型提供安全接口\n\n3. 验证阶段\n   - 运行cargo check确保编译通过\n   - 检查所有unsafe块都有SAFETY注释\n   - 验证空指针处理逻辑的正确性\n   - 确认没有破坏向后兼容性\n\n注意事项：\n- 不要移除必要的unsafe块，FFI交互无法避免\n- 不要改变公开的FFI接口签名\n- 优先使用Option而非panic处理错误情况\n- SAFETY注释要具体说明前置条件和调用者责任\n\n可选步骤：\n- 添加单元测试验证空指针处理逻辑\n- 使用静态分析工具验证unsafe使用安全性\n- 文档化FFI函数的行为约定和错误条件"
}