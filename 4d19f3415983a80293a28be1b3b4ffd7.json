{
  "problem_type": "C函数到Rust转译",
  "content": "## C→Rust函数转译方法论\n\n### 问题重述\n将C风格的函数（使用原始指针、全局变量、可变参数等）转译为符合Rust惯用法的安全代码，同时保持行为一致性。\n\n### 可复用解决流程\n\n#### 阶段1：接口分析\n1. **提取函数签名**：使用`lsp_client`获取原函数定义\n2. **参数映射**：\n   - `char*` → `Option<&str>`（可为空字符串）\n   - `int` → `i32`（或更精确的整数类型）\n   - `bool` → `bool`\n   - 输出参数 → `&mut T`或返回值Tuple\n3. **错误处理**：C的错误码 → `Result<T, E>`\n\n#### 阶段2：占位实现\n1. **创建测试模块**：按功能分组（如`print_dependencies_tests`）\n2. **写测试用例**：覆盖主要使用场景和边界条件\n3. **添加占位符**：使用`unimplemented!()`暂时占位\n\n#### 阶段3：实现与修复\n1. **基础实现**：\n   ```rust\n   pub fn func_name(...) -> Result<..., Box<dyn Error>> {\n       unimplemented!()\n   }\n   ```\n2. **逐步替换**：每次解决一个编译错误\n3. **类型修复优先级**：\n   - 生命周期问题（临时值引用）\n   - 所有权问题（String vs &str）\n   - 错误处理问题（?运算符使用）\n\n#### 阶段4：验证与优化\n1. **构建验证**：自动检查语法和类型\n2. **测试运行**：`cargo test --lib 模块名`\n3. **代码审查**：检查是否符合Rust惯用法\n\n### 注意事项\n- **命名规范**：snake_case（如`opt_mf`）\n- **错误传播**：优先使用`?`运算符\n- **内存安全**：避免裸指针，使用标准库类型\n- **测试覆盖**：至少包含：基本路径、边界条件、错误路径\n\n### 可选步骤\n- **性能优化**：使用`Cow<str>`避免不必要的克隆\n- **文档注释**：添加中文文档字符串\n- **集成测试**：在真实项目中验证行为一致性"
}