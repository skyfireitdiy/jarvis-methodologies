{
  "problem_type": "C到Rust函数级代码修复",
  "content": "# C到Rust函数级代码修复方法论\n\n## 适用场景\n当需要将C语言实现的核心函数迁移到Rust，或修复现有Rust实现中的功能一致性问题时使用。\n\n## 解决流程\n\n### 1. 现状分析阶段\n- **工具组合**: read_code + lsp_client + test运行\n- **关键动作**:\n  - 读取当前Rust实现与C源码进行比对\n  - 使用lsp_client搜索相关符号和依赖\n  - 运行`cargo test`确认测试基线\n- **判断标准**: 识别\"仅返回Ok(0)\"的简化实现或功能缺失\n\n### 2. 兼容性处理阶段\n- **工具组合**: read_code + edit_file\n- **处理策略**:\n  - 检查Rust类型系统与C代码需求差异\n  - 使用现有库函数替代C特有操作（如gstate_iszero替代xor）\n  - 保持函数签名不变，内部实现渐进式完善\n\n### 3. 功能框架构建阶段\n- **实现模式**:\n  ```rust\n  // 从空实现到功能框架\n  fn original() -> Result<(), Error> { Ok(()) }\n \n  // 改进为框架实现\n  fn improved() -> Result<(), Error> {\n      // 1. 参数验证\n      // 2. 状态计算（使用现有工具函数）\n      // 3. 核心逻辑占位\n      // 4. 错误处理\n      Ok(())\n  }\n  ```\n\n### 4. 验证阶段\n- **强制验证**: `cargo test -- --nocapture`\n- **回归检查**: 确保所有原有测试通过\n- **风格清理**: 处理unused变量警告\n\n## 注意事项\n1. 禁止重构未修改部分\n2. 优先使用现有代码库提供的工具函数\n3. 复杂状态处理可暂时简化，但保留扩展点\n4. 所有测试必须通过后方可提交\n\n## 工具依赖\n- read_code: 读取相关源文件\n- edit_file: 精确修改函数实现\n- execute_script: 运行cargo test验证"
}