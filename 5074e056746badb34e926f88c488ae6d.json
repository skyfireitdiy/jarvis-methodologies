{
  "problem_type": "SA-IS算法L/S类型分类实现",
  "content": "**问题重述：** 实现SA-IS算法的第一步L/S类型分类，将输入序列的每个字符分类为L型或S型，要求纯Rust安全代码，O(n)时间复杂度，无额外内存分配。\n\n**可复用解决流程：**\n\n1. **理解SA-IS分类规则**\n   - L-type：当前字符 > 下一个字符，或相等但下一个为L-type\n   - S-type：当前字符 < 下一个字符，或相等但下一个为S-type\n   - 最后一个字符默认为S-type\n\n2. **实现classify_types函数**\n   ```rust\n   fn classify_types(input: &[u8]) -> Vec<bool> {\n       let n = input.len();\n       let mut types = vec![true; n]; // 默认S-type\n      \n       if n > 0 {\n           types[n - 1] = true; // 最后一个字符为S-type\n          \n           for i in (0..n-1).rev() {\n               match input[i].cmp(&input[i + 1]) {\n                   Ordering::Less => types[i] = true,      // S-type\n                   Ordering::Greater => types[i] = false,  // L-type\n                   Ordering::Equal => types[i] = types[i + 1], // 继承\n   }\n   }\n   }\n      \n       types\n   }\n   ```\n\n3. **边界条件处理**\n   - 空输入：直接返回空Vec\n   - 单字符：返回包含单个true的Vec\n   - 数组边界：使用`n-1`确保不越界\n\n4. **性能优化**\n   - 从右向左遍历避免重复计算\n   - 单次线性扫描O(n)时间复杂度\n   - 仅分配结果数组，无额外内存\n\n5. **测试验证**\n   - 基本功能测试：空输入、单字符、简单字符串\n   - 边界情况测试：全相同字符、升降序字符\n   - 与已知正确结果对比验证\n\n**注意事项：**\n- 字符比较使用字节值直接比较\n- 相等字符的类型继承是关键逻辑\n- 确保Rust安全代码，避免unsafe块\n\n**可选步骤：**\n- 添加更复杂的测试用例（特殊字符、长字符串）\n- 性能基准测试验证O(n)复杂度\n- 与C实现结果对比验证正确性"
}