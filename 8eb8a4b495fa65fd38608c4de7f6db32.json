{
  "problem_type": "动态链接库RTLD_GLOBAL问题分析",
  "content": "动态链接库RTLD_GLOBAL问题分析方法论\n\n=== 问题重述 ===\n当使用dlopen传入RTLD_GLOBAL参数，然后dlsym（使用RTLD_DEFAULT），再dlclose时，被打开的库仍然可以被RTLD_DEFAULT访问到。\n\n=== 可复用解决流程 ===\n1. 理论分析阶段\n   - 理解RTLD_GLOBAL的作用：将符号导出到全局符号表\n   - 理解RTLD_DEFAULT的工作机制：在全局符号表中搜索\n   - 理解dlclose的行为：只减少引用计数，不清理符号表\n\n2. 实验验证阶段\n   - 创建测试程序，使用预加载库（如libc）测试\n   - 创建测试程序，使用非预加载库（如libz、libm）测试\n   - 检查/proc/self/maps中的映射情况\n   - 验证dlclose后RTLD_DEFAULT是否仍然有效\n\n3. 结果分析阶段\n   - 对比预加载库和非预加载库的行为差异\n   - 分析maps中映射的存在与否\n   - 确认符号持久性的根本原因\n\n=== 工具使用 ===\n- rewrite_file：创建测试程序\n- execute_script：编译并运行测试\n- read_webpage：获取man page信息\n- save_memory：保存分析结果\n\n=== 注意事项 ===\n- 确保测试程序使用_GNU_SOURCE宏定义\n- 测试时要使用不同的库类型（预加载vs非预加载）\n- maps中看不到映射不代表库没有被加载\n- RTLD_GLOBAL的符号导出是持久的\n\n=== 可选步骤 ===\n- 使用lsp_client工具分析glibc源码\n- 创建更复杂的测试场景\n- 测试不同的RTLD标志组合\n\n=== 结论 ===\n这不是bug，而是glibc的设计特性。RTLD_GLOBAL创建的全局符号导出在dlclose后没有被正确清理。"
}