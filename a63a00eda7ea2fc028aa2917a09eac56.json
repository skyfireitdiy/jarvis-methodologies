{
  "problem_type": "SA-IS算法验证与实现",
  "content": "SA-IS算法验证与实现方法论\n\n问题重述：\n实现线性时间SA-IS（Suffix Array Induced Sorting）算法替换现有O(n log n)排序算法，要求：\n- 保持API兼容性（input: &[u8] -> Vec<i32>）\n- 纯Rust安全代码，避免unsafe\n- 验证算法正确性（通过所有测试用例）\n- 性能提升25-50%\n\n可复用解决流程：\n\n阶段1：算法框架搭建\n1. 创建核心文件：src/compress/sais_algorithm.rs\n2. 定义四个核心模块：\n   - L/S类型分类算法（classify_types）\n   - 桶排序预处理（compute_buckets）\n   - 诱导排序主逻辑（induce_sort_l/induce_sort_s）\n   - 递归处理缩减问题（create_reduced_problem）\n3. 定义API接口：pub fn sais_sort(input: &[u8]) -> Vec<i32>\n\n阶段2：正确性验证\n1. 编写单元测试：\n   - 边界测试：空输入、单字符输入\n   - 典型用例：banana → [5,3,1,0,4,2]\n   - 回归测试：mississippi、aaa、aab等\n2. 运行验证：cargo test compress::sais_algorithm::tests --no-fail-fast\n3. 确保所有测试通过\n\n阶段3：系统集成\n1. 在src/compress/mod.rs中添加mod sais_algorithm\n2. 在block_sort.rs中替换原有排序逻辑：\n   ```rust\n   let sa_result = crate::compress::sais_algorithm::sais_sort(&block[..nblock]);\n   for (i, &val) in sa_result.iter().enumerate() {\n       ptr[i] = val as u32;\n   }\n   ```\n3. 保持API兼容性：使用let _ = (arr1, arr2, ftab, work_factor, verbosity)维持参数列表\n\n阶段4：性能验证\n1. 基准测试：使用test_roundtrip_50mb验证性能\n2. 预期结果：25-50%性能提升\n3. 验证标准：\n   - 所有现有集成测试通过\n   - perf报告显示排序热点开销降低\n   - 算法复杂度从O(n log n)降至O(n)\n\n注意事项：\n- 当前实现使用临时排序（第29-32行），需要替换为真正的SA-IS算法\n- 所有辅助函数已正确实现但未被调用（create_reduced_problem等）\n- 确保递归处理LMS子串的正确性\n- 内存使用优化，避免不必要的复制\n\n可选步骤：\n- 添加性能基准测试\n- 实现更高效的桶排序\n- 优化递归深度和内存使用"
}