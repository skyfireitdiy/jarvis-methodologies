{
  "problem_type": "Rust unsafe代码安全重构",
  "content": "## 问题重述\n需要安全重构包含unsafe代码和裸指针转换的Rust函数，移除所有unsafe操作，使用安全的引用操作保持原有逻辑功能不变。\n\n## 可复用解决流程\n\n### 步骤1：识别unsafe代码模式\n使用工具：\n- `read_code` - 读取目标函数完整实现\n- `rg \\\"unsafe\\\"` - 搜索unsafe关键字\n- `rg \\\"as \\\\*\\\"` - 搜索裸指针转换\n\n常见unsafe模式：\n1. 裸指针转换：`as *const T as *mut T`\n2. unsafe解引用：`unsafe { &mut *ptr }`\n3. 原始指针算术运算\n\n### 步骤2：功能验证基线\n执行命令：\n```bash\ncargo test <模块路径> -- --nocapture\n```\n记录所有测试用例的通过状态，作为重构后的功能验证基准。\n\n### 步骤3：安全重构策略\n根据unsafe模式选择对应策略：\n\n**裸指针转换模式**：\n- 原代码：`expr.as_ref() as *const Token as *mut Token`\n- 重构方案：用安全引用替换\n  - 如果可能，直接使用`&mut expr`而非转换\n  - 使用`Option<Box<T>>`的`as_mut()`方法\n  - 考虑重新设计API避免需要可变引用\n\n**unsafe解引用模式**：\n- 原代码：`unsafe { &mut *expr_ptr }`\n- 重构方案：消除unsafe需求\n  - 保持使用安全引用链式访问\n  - 重构数据结构避免需要原始指针\n\n### 步骤4：增量验证\n每移除一处unsafe代码后立即：\n1. 运行`cargo check`确保编译通过\n2. 运行`cargo test <模块路径>`确保功能未退化\n3. 运行`cargo clippy`检查是否有更优写法\n\n### 步骤5：最终验证\n完成所有重构后：\n1. 全量测试验证：`cargo test`\n2. 安全验证：确认无剩余unsafe代码\n3. 性能验证：如有需要运行基准测试\n\n## 注意事项\n- 保持API签名不变，避免破坏调用者\n- 特别注意生命周期标注，确保引用有效性\n- 对于链表结构，优先使用Option<Box<T>>的内置方法\n- 避免使用unsafe的transmute或forget\n\n## 可选步骤\n- 添加单元测试覆盖边界情况\n- 使用`#[deny(unsafe_code)]`属性禁止未来引入unsafe\n- 考虑添加性能基准测试确保重构无性能退化"
}