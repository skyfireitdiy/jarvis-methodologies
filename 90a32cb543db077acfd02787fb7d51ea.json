{
  "problem_type": "Rust函数测试增强",
  "content": "# Rust函数测试增强方法论\n\n## 问题场景\n为已实现的Rust函数添加缺失的测试用例，确保功能正确性和边界覆盖。\n\n## 可复用解决流程\n\n### 阶段1：现状分析\n1. **确认函数实现完整性**：\n   - 使用`read_code`查看目标函数完整实现\n   - 检查所有依赖函数是否已实现\n   - 使用`lsp_client`搜索相关符号定义\n\n2. **分析类型依赖**：\n   - 使用`read_code`检查相关类型定义\n   - 确认测试所需的所有类型和构造函数\n   - 记录字段完整性和默认值\n\n### 阶段2：测试设计\n1. **测试用例类别**：\n   - 基础功能测试：正常输入输出\n   - 边界条件测试：极值、特殊值\n   - 错误场景测试：异常输入、错误状态\n   - 类型测试：不同类型转换和兼容性\n\n2. **测试结构**：\n   ```\n   #[cfg(test)]\n   mod function_name_tests {\n       use super::*;\n       use 必要的导入;\n      \n       #[test]\n       fn test_基础功能() { ... }\n      \n       #[test]\n       fn test_边界条件() { ... }\n      \n       #[test]\n       fn test_错误场景() { ... }\n   }\n   ```\n\n### 阶段3：实现与验证\n1. **测试实现技巧**：\n   - 使用现有工厂函数创建测试数据\n   - 避免直接构造复杂类型\n   - 处理临时变量的生命周期问题\n\n2. **编译验证**：\n   - 使用`cargo test -- --nocapture`运行测试\n   - 逐个修复编译错误\n   - 确保所有测试通过\n\n### 注意事项\n- 确认所有类型和函数在测试模块中可访问\n- 处理Rust特有生命周期问题\n- 避免使用未定义的复杂类型\n- 优先使用现有构造函数和工具函数\n\n### 可选步骤\n- 添加性能测试用例\n- 考虑输入边界值的测试\n- 添加错误消息验证"
}