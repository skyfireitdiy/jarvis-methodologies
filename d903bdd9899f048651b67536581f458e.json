{
  "problem_type": "C到Rust内存管理修复",
  "content": "## C到Rust内存管理修复方法论\n\n### 问题重述\n在C到Rust转译过程中，常见的内存管理问题包括：\n- malloc/free与Box/Vec不匹配\n- 悬垂指针和解引用错误\n- 双重释放或内存泄漏\n- clippy警告和类型安全问题\n\n### 可复用解决流程\n\n1. **问题诊断阶段**\n   - 运行`cargo test`获取错误信息\n   - 识别内存错误类型（SIGABRT、SIGSEGV等）\n   - 使用工具：`execute_script`运行测试\n\n2. **根因分析**\n   - 检查分配点：寻找`Box::into_raw`、`Vec::into_raw_parts`等\n   - 检查释放点：寻找`Box::from_raw`、`Vec::from_raw_parts`\n   - 验证类型匹配：确保分配和释放使用相同类型\n   - 使用工具：`read_code`查看相关代码段\n\n3. **修复策略选择**\n   - 优先使用`Box<[T]>`模式：分配释放一致性最好\n   - 次选`Layout`+`alloc`：需要精确内存控制时使用\n   - 避免混用`Vec`和`Box`释放\n\n4. **实施修复**\n   - 修改分配：`Box::into_raw(Box::<[T]>::from(data))`\n   - 修改释放：`Box::from_raw(core::ptr::slice_from_raw_parts_mut(ptr, len))`\n   - 边界处理：空切片(0长度)的正确处理\n\n5. **验证流程**\n   - 编译检查：`cargo check`\n   - 质量检查：`cargo clippy -- -D warnings`\n   - 单元测试：`cargo test --lib`\n   - 核心测试：运行相关模块的测试子集\n\n### 注意事项\n- 始终确保`Box::into_raw`和`Box::from_raw`成对使用\n- 空切片(0长度)需要特殊处理，但遵循相同模式\n- clippy警告通常是类型安全问题的信号\n- 对于复杂场景，考虑使用RAII包装器\n\n### 可选步骤\n- 添加内存调试工具：`valgrind`或`miri`\n- 实现内存泄漏检测测试\n- 添加边界条件测试用例"
}