{
  "problem_type": "Rust破坏性变更修复",
  "content": "# Rust破坏性变更修复方法论\n\n## 问题场景\n当Rust函数需要添加新参数（如全局变量转显式参数）或改变返回类型时，会造成破坏性变更。\n\n## 解决流程\n\n### 1. 影响分析\n- 使用 `cargo build` 查看所有编译错误\n- 使用 `grep -r \\\"函数名\\\" src/` 查找所有调用点\n- 评估变更范围\n\n### 2. 兼容策略选择\n- **策略A**：保留原签名 + 创建新函数（推荐）\n- **策略B**：函数重载（trait或impl块）\n- **策略C**：宏封装\n\n### 3. 实施步骤（策略A）\n1. 重命名原函数：`sed -i 's/旧名(/新名(/g'`\n2. 创建兼容函数：使用原签名调用新函数\n3. 更新测试用例：测试新函数\n4. 验证：`cargo test`\n5. 文档更新：标记旧函数为#[deprecated]\n\n### 4. 工具组合\n- `sed`：批量重命名调用点\n- `cargo test`：验证不破坏功能\n- `git diff`：审查变更范围\n\n### 5. 注意事项\n- 保持函数语义不变\n- 新函数应该有更明确的命名\n- 测试用例需要覆盖新旧两种调用方式\n- 考虑性能影响（兼容层可能有轻微开销）"
}