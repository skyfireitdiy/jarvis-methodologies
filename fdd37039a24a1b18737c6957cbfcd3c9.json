{
  "problem_type": "Rust全局状态管理修复",
  "content": "## 问题重述\n修复Rust项目中TMPFILES等全局状态的管理，解决测试间状态污染、并发访问安全、文件清理不彻底和竞态条件问题。\n\n## 可复用解决流程\n\n### 步骤1: 全局状态封装\n使用线程安全的方式封装全局状态：\n- 使用 `once_cell::sync::Lazy` + `Mutex<T>` 组合\n- 实现错误处理机制（处理Mutex poisoned情况）\n- 添加状态重置函数\n\n```rust\nuse once_cell::sync::Lazy;\nuse std::sync::{Mutex, PoisonError};\n\nstatic TMPFILES: Lazy<Mutex<Vec<String>>> = Lazy::new(|| Mutex::new(Vec::new()));\n\nfn get_locked_guard<'a, T>(guard: Result<MutexGuard<'a, T>, PoisonError<MutexGuard<'a, T>>>) -> MutexGuard<'a, T> {\n    match guard {\n        Ok(guard) => guard,\n        Err(e) => {\n            eprintln!(\"警告: 全局状态Mutex被poisoned，正在恢复\");\n            e.into_inner()\n}\n}\n}\n```\n\n### 步骤2: 资源清理机制\n实现可靠的资源清理：\n- 使用RAII模式包装临时资源\n- 实现双重清理（即使第一次失败也继续尝试）\n- 记录清理失败的路径以便后续处理\n\n```rust\n#[cfg(test)]\npub fn reset_tmpfiles() {\n    let mut guard = get_locked_guard(TMPFILES.lock());\n   \n    // 确保所有文件都被清理\n    let mut failed_paths = Vec::new();\n    for path in guard.iter() {\n        if let Err(e) = fs::remove_file(path) {\n            if e.kind() != io::ErrorKind::NotFound {\n                failed_paths.push(path.clone());\n}\n}\n}\n   \n    // 重试清理失败的文件\n    for path in failed_paths.iter() {\n        let _ = fs::remove_file(path);\n}\n   \n    guard.clear();\n    assert!(guard.is_empty(), \"全局状态应该为空\");\n}\n```\n\n### 步骤3: 测试隔离增强\n改进测试间的状态隔离：\n- 每个测试前后都调用reset函数\n- 使用测试框架的setup/teardown\n- 添加测试间的状态验证\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n   \n    #[test]\n    fn test_isolation() {\n        reset_tmpfiles(); // 测试前清理\n       \n        // 测试代码\n       \n        reset_tmpfiles(); // 测试后清理\n}\n}\n```\n\n### 步骤4: 并发安全验证\n验证并发访问安全：\n- 使用 `cargo test --release` 多次运行\n- 检查是否有残留临时文件\n- 验证测试状态一致性\n\n## 注意事项\n1. 避免在多线程测试中使用全局可变状态\n2. 考虑使用测试框架的fixture替代全局状态\n3. 临时文件建议使用 `tempfile::NamedTempFile` 的RAII特性\n4. 测试失败后确保清理代码仍执行（使用 `Drop` trait）\n\n## 可选步骤\n- 实现测试专用的临时文件管理器\n- 使用 `lazy_static` 替代 `once_cell`（兼容性考虑）\n- 添加测试并发控制（如 `serial_test` crate）"
}