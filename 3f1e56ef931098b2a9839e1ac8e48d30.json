{
  "problem_type": "OpenHarmony安全扫描问题修复",
  "content": "### 问题描述\n修复OpenHarmony项目中通过静态代码分析发现的安全问题，包括但不限于：\\n- 空指针解引用\\n- 文件描述符未验证\\n- 内存分配失败未处理\\n- 类型转换前未验证数据长度\\n- IO操作返回值未检查\\n\\n### 可复用解决流程\\n\\n#### 步骤1：问题识别与分类\\n1. 使用静态分析工具（如clang-tidy）扫描代码\\n2. 按问题类型分类整理：\\n   - 内存安全问题（空指针、内存泄漏）\\n   - 资源管理问题（文件描述符、句柄）\\n   - 类型转换问题（reinterpret_cast、static_cast）\\n   - IO安全问题（返回值检查）\\n\\n#### 步骤2：修复策略制定\\n对每个问题类型应用对应修复模式：\\n\\n**文件描述符问题**：\\n- 检查标准：fd >= 0或fd > 0\\n- 修复模式：\\n  ```cpp\\n  if (fd >= 0) {\\n      close(fd);\\n  }\\n  ```\\n\\n**空指针检查**：\\n- 检查标准：nullptr或NULL\\n- 修复模式：\\n  ```cpp\\n  if (ptr == nullptr) {\\n      return -1; // 或合适的错误码\\n  }\\n  ```\\n\\n**reinterpret_cast检查**：\\n- 检查标准：数据长度 >= 目标类型大小\\n- 修复模式：\\n  ```cpp\\n  if (data_len < sizeof(TargetType)) {\\n      std::cout << \\\"Error: data length too small\\\" << std::endl;\\n      return;\\n  }\\n  T* result = reinterpret_cast<T*>(data);\\n  ```\\n\\n**内存分配检查**：\\n- 使用std::nothrow模式\\n- 修复模式：\\n  ```cpp\\n  Type* ptr = new (std::nothrow) Type(args);\\n  if (ptr == nullptr) {\\n      return default_value; // 合适的默认值\\n  }\\n  ```\\n\\n#### 步骤3：代码修改与验证\\n1. **修改原则**：\\n   - 保持API签名不变\\n   - 使用项目已有错误处理模式\\n   - 最小化修改范围\\n   - 添加适当的错误日志\\n\\n2. **验证步骤**：\\n   - 编译验证：确保修改后代码可编译\\n   - 静态分析：重新运行分析工具确认问题已解决\\n   - 功能测试：确保不破坏现有功能\\n\\n#### 步骤4：文档记录\\n1. 记录修复的问题类型和位置\\n2. 更新相关文档说明修复的约束条件\\n3. 保存修复模式用于后续类似问题\\n\\n### 注意事项\\n1. **禁止事项**：\\n   - 不修改现有API签名\\n   - 不引入新的依赖\\n   - 不删除现有功能\\n   - 不进行大范围重构\\n\\n2. **验证要求**：\\n   - 每个修复必须有对应的验证测试\\n   - 保持向后兼容性\\n   - 符合OpenHarmony代码风格\\n\\n3. **工具建议**：\\n   - 使用read_code查看完整上下文\\n   - 使用execute_script运行静态分析工具\\n   - 使用save_memory记录修复经验\\n\\n### 可选步骤\\n- 对于复杂问题，可以创建专门的修复工具\\n- 定期回顾并更新修复方法论"
}