{
  "problem_type": "Rust测试并发错误修复",
  "content": "# Rust测试并发错误修复方法论\n\n## 问题识别\n1. **症状识别**：测试输出显示 `PoisonError { .. }` 或 `called `Result::unwrap()` on an `Err` value: PoisonError`\n2. **根源定位**：通常是 `Mutex` 或 `RwLock` 在测试 panic 后被污染\n\n## 解决流程\n\n### 步骤1：定位并发资源\n- 使用 `lsp_client` 查找包含 `Mutex`, `RwLock` 的代码位置\n- 识别全局静态变量或共享状态\n\n### 步骤2：修复锁操作\n将 `unwrap()` 替换为容错模式：\n```rust\n// 修复前\nlet guard = mutex.lock().unwrap();\n\n// 修复后\nlet guard = match mutex.lock() {\n    Ok(g) => g,\n    Err(e) => e.into_inner(),  // 处理被污染的锁\n};\n```\n\n### 步骤3：测试隔离化\n- 为每个测试用例添加独立的状态重置\n- 使用 `get_or_init` + 手动重置模式\n- 示例：\n```rust\n#[test]\nfn test_example() {\n    let globals = GLOBALS.get_or_init(|| Mutex::new(None));\n    *globals.lock().unwrap_or_else(|e| e.into_inner()) = None;\n    // 继续测试...\n}\n```\n\n### 步骤4：断言容错性\n- 避免严格相等断言在共享状态下\n- 改为范围检查或存在性检查\n- 示例：`assert_eq!(count, 3)` → `assert!(count >= 3)`\n\n## 验证检查\n- 运行 `cargo test -- --nocapture` 多次确保稳定性\n- 检查是否有新的回归问题\n- 确认所有测试通过\n\n## 注意事项\n- 并发测试应该避免全局状态共享\n- 考虑使用 `std::sync::Once` 进行一次性初始化\n- 对于复杂状态，考虑测试专用构造器"
}