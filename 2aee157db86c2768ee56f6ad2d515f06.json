{
  "problem_type": "Rust并发测试污染问题处理",
  "content": "## Rust并发测试污染问题处理方法论\n\n### 问题重述\n当Rust测试使用全局静态变量（如Mutex、Lazy静态变量）时，多线程并发执行可能导致测试间状态污染，表现为：\n- 测试单独运行通过，批量运行失败\n- 测试结果不稳定，时好时坏\n- 全局状态未按预期清理\n\n### 可复用解决流程\n\n#### 步骤1：快速诊断\n```bash\n# 单线程运行测试验证\ncargo test -- --test-threads=1 --nocapture\n\n# 如果单线程通过，确认为并发污染\n```\n\n#### 步骤2：分类处理\n1. **测试代码问题**：检查是否正确清理全局状态\n   - 确认每个测试都有适当的setup/teardown\n   - 验证clear_*函数是否正确清除了所有相关状态\n\n2. **执行环境问题**：强制单线程执行\n   - 在CI/CD中添加单线程测试验证\n   - 对关键测试使用`#[serial]`属性（需添加serial_test依赖）\n\n3. **状态隔离问题**：重构测试避免共享状态\n   - 使用测试专用的配置\n   - 考虑使用临时文件替代全局内存状态\n\n#### 步骤3：验证修复\n```bash\n# 单线程验证\ncargo test -- --test-threads=1\n\n# 多线程验证（用于确认修复）\ncargo test -- --test-threads=4\n```\n\n### 注意事项\n- 全局静态变量在多线程测试中需要特别注意状态隔离\n- 测试失败可能是间歇性的，需要多次运行确认\n- 考虑使用`once_cell::sync::Lazy`配合适当的清理机制\n- 对于关键测试，可以强制使用`#[cfg(test)]`条件编译\n\n### 可选步骤\n- 添加测试隔离的辅助函数\n- 使用测试fixture管理全局状态\n- 考虑使用mock对象替代真实全局状态"
}