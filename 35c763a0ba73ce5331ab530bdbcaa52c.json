{
  "problem_type": "Rust-C FFI符号导出到动态库",
  "content": "## Rust-C FFI符号导出到动态库解决方法论\n\n### 问题重述\n当使用Rust创建动态库(dylib)并需要导出C函数给其他程序使用时，即使C函数在静态库中可见，也不会自动出现在最终生成的Rust动态库中。\n\n### 可复用解决流程\n\n#### 步骤1：确认C函数符号可见性\n1. 检查C源代码中函数声明：\n   ```c\n   __attribute__((visibility(\"default\"))) int my_function(int arg);\n```\n2. 验证C对象文件包含符号：\n```bash\n   nm c_object_file.o | grep my_function\n```\n\n#### 步骤2：配置build.rs编译参数\n在build.rs中添加符号导出标志：\n```rust\ncc::Build::new()\n    .file(\"src/my_function.c\")\n    .flag(\"-fvisibility=default\")\n    .flag(\"-rdynamic\")\n    .compile(\"my_static_lib\");\n```\n\n#### 步骤3：Rust代码中显式重新导出\n在Rust库代码中添加重导出声明：\n```rust\n    #[no_mangle]\npub extern \"C\" fn my_function(arg: c_int) -> c_int {\n    unsafe { bindings::my_function(arg) }\n}\n```\n\n#### 步骤4：验证符号导出\n使用以下命令验证符号已导出为GLOBAL：\n```bash\nnm -D target/debug/libyour_library.so | grep my_function\n```\n预期输出应包含：地址 T my_function\n\n### 注意事项\n- 仅配置C代码的visibility和build.rs参数不足以导出符号\n- Rust dylib默认只导出Rust符号，必须显式重新导出C符号\n- 确保Cargo.toml中crate-type包含\"dylib\"\n- 使用#[no_mangle]防止Rust名称改编\n\n### 可选步骤\n如需导出多个C函数，可以创建导出模块统一处理：\n```rust\npub mod exports {\n    #[no_mangle]\n    pub extern \"C\" fn func1() { unsafe { super::bindings::func1() } }\n    #[no_mangle] \n    pub extern \"C\" fn func2() { unsafe { super::bindings::func2() } }\n}\n```"
}