{
  "problem_type": "Rust模块反向工程分析",
  "content": "# Rust 模块反向工程分析方法论\n\n## 规则简介\n\n本方法论提供了从 Rust 模块代码中提取设计信息并生成语言无关设计方案的系统化流程。适用于理解 Rust crate 的架构、模块关系、整体设计，为新团队成员提供模块概览、重构前的架构分析、模块文档化等场景。\n\n## 你必须遵守的原则\n\n### 完整性原则\n\n- **必须**：确保设计方案覆盖所有公共接口、结构体、枚举和核心功能\n- **禁止**：遗漏任何 pub 可见的 API 或功能\n- **必须**：提供功能对照表验证完整性\n- **必须**：分析 lib.rs 以识别所有公共导出\n\n### 系统性原则\n\n- **必须**：从 lib.rs 开始，系统性地分析整个模块结构\n- **必须**：按照目录层次组织分析任务\n- **禁止**：遗漏任何子模块或关键文件\n- **必须**：建立完整的模块清单\n\n### 可追溯性原则\n\n- **必须**：记录每个设计决策对应的代码位置\n- **禁止**：凭空猜测代码功能\n- **必须**：提供关键代码片段的引用（文件名:行号）\n- **必须**：记录分析的代码来源（目录和文件列表）\n\n### 依赖分析原则\n\n- **必须**：分析 Cargo.toml 识别所有外部依赖\n- **必须**：识别模块对其他模块的依赖关系\n- **必须**：识别模块提供的公共 API\n- **禁止**：忽略任何依赖项\n\n## 你必须执行的操作\n\n### 阶段1：信息收集\n\n1. **扫描模块目录**\n   - 使用 fd 或 execute_script 列出模块目录结构\n   - 识别源代码目录（src/）\n   - 识别测试目录（tests/ 或 src/tests/）\n   - 识别配置文件（Cargo.toml）\n\n2. **读取入口文件**\n   - 使用 read_code 读取 src/lib.rs\n   - 识别所有 pub 导出的类型、函数、trait\n   - 识别模块声明和子模块\n\n3. **读取依赖配置**\n   - 使用 read_code 读取 Cargo.toml\n   - 记录所有依赖项及其版本\n   - 记录依赖的特性（features）\n\n4. **读取关键源文件**\n   - 根据 lib.rs 的模块声明，读取各个子模块文件\n   - 优先读取包含 pub struct、pub enum、pub fn 的文件\n   - 记录每个文件的主要功能和职责\n\n### 阶段2：组件分析\n\n1. **识别核心组件**\n   - 分析所有 pub struct：记录字段、impl 块、公共方法\n   - 分析所有 pub enum：记录变体和 impl 块\n   - 分析所有 pub trait：记录方法和默认实现\n   - 分析所有 pub fn：记录参数、返回值、功能\n\n2. **分析依赖关系**\n   - 识别每个组件对其他组件的依赖\n   - 识别组件对外部库的依赖\n   - 识别组件的输入输出接口\n\n3. **识别设计模式**\n   - 检查是否使用了常见设计模式（工厂、单例、策略等）\n   - 记录模式的应用位置和实现方式\n\n### 阶段3：文档生成\n\n1. **生成模块文档**\n   - 按照反向工程规则的格式生成文档\n   - 包含模块概述、模块结构、核心组件、依赖关系\n   - 包含接口设计、数据流、设计决策、关键代码位置\n   - 包含代码来源记录（目录和文件列表）\n\n2. **生成功能对照表**\n   - 列出所有识别的功能点\n   - 记录每个功能对应的组件和代码位置\n   - 标注功能状态（✅/❌）\n\n3. **验证文档完整性**\n   - 检查是否覆盖所有公共 API\n   - 检查是否包含代码来源信息\n   - 检查文档格式是否符合规范\n\n## 实践指导\n\n### 代码阅读技巧\n\n1. **从入口开始**：优先阅读 lib.rs，了解模块的整体结构和公共 API\n2. **关注类型定义**：pub struct、pub enum、pub trait 是模块的核心抽象\n3. **关注实现细节**：impl 块中的方法定义了组件的行为\n4. **理解模块组织**：mod 声明揭示了模块的层次结构\n5. **识别关键trait**：实现了标准库或知名 trait（如 Read、Write、Log）的组件通常是核心功能\n\n### 依赖分析方法\n\n1. **Cargo.toml 分析**：记录所有直接依赖，理解外部依赖的用途\n2. **use 语句分析**：识别模块内部对其他模块的依赖\n3. **类型依赖分析**：分析结构体字段、函数参数、返回值的类型依赖\n\n### 设计模式识别\n\n1. **Factory 模式**：查找名为 new、create、build 等的关联函数\n2. **Builder 模式**：查找链式调用方法（返回 Self）\n3. **单例模式**：查找 static、LazyLock、Arc<Mutex>> 等全局变量\n4. **策略模式**：查找 trait 定义和枚举变体\n5. **模板方法模式**：查找 trait 实现\n\n### 文档编写技巧\n\n1. **语言无关描述**：使用通用的设计概念，避免 Rust 特定语法\n2. **结构化表达**：使用清晰的层次结构组织内容\n3. **代码位置索引**：使用 `文件名:行号` 格式记录代码位置\n4. **功能对照表**：提供功能清单和对应代码位置的表格\n\n## 检查清单\n\n### 信息收集阶段\n\n- [ ] 已扫描模块目录结构\n- [ ] 已读取并分析 lib.rs\n- [ ] 已读取并分析 Cargo.toml\n- [ ] 已读取所有关键源文件\n- [ ] 已记录所有 pub 导出的 API\n\n### 组件分析阶段\n\n- [ ] 已分析所有 pub struct\n- [ ] 已分析所有 pub enum\n- [ ] 已分析所有 pub trait\n- [ ] 已分析所有 pub fn\n- [ ] 已识别组件间的依赖关系\n- [ ] 已识别使用的设计模式\n\n### 文档生成阶段\n\n- [ ] 已生成模块文档\n- [ ] 文档包含模块概述\n- [ ] 文档包含模块结构\n- [ ] 文档包含核心组件列表\n- [ ] 文档包含依赖关系分析\n- [ ] 文档包含接口设计\n- [ ] 文档包含数据流\n- [ ] 文档包含设计决策\n- [ ] 文档包含关键代码位置\n- [ ] 文档包含代码来源信息\n- [ ] 文档包含功能对照表\n\n### 质量检查\n\n- [ ] 设计方案语言无关，不包含 Rust 语法\n- [ ] 所有公共 API 都已记录\n- [ ] 所有代码位置都已索引\n- [ ] 文档格式符合规范\n- [ ] 功能对照表完整",
  "scope": "global"
}