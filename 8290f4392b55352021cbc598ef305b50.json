{
  "problem_type": "Rust测试失败诊断与误解澄清",
  "content": "## Rust测试失败诊断方法论\n\n### 问题重述\n在分析Rust测试失败时，可能会遇到测试输出信息与实际测试状态不符的情况，特别是涉及`#[should_panic]`属性的测试或测试环境状态问题。\n\n### 可复用解决流程\n\n**步骤1：初步信息收集**\n- 使用 `cargo test -- --nocapture` 获取完整测试输出\n- 记录失败测试的名称和错误信息\n- 注意是否有`#[should_panic]`标记\n\n**步骤2：单独验证测试**\n- 使用 `cargo test test_name -- --nocapture` 单独运行失败测试\n- 对比单独运行与批量运行的结果差异\n\n**步骤3：分析测试属性**\n- 检查测试函数是否有`#[test]`、`#[should_panic]`等属性\n- 使用 `read_code` 工具查看测试函数定义\n- 确认测试预期行为（通过、panic、忽略等）\n\n**步骤4：验证测试环境**\n- 清理测试缓存：`cargo clean`\n- 重置测试状态（如本例中的临时文件状态）\n- 使用 `reset_tmpfiles()` 等清理函数\n\n**步骤5：交叉验证**\n- 使用 `cargo test --lib` 仅运行库测试\n- 使用 `cargo test --bin` 仅运行二进制测试\n- 使用 `cargo test --doc` 运行文档测试\n\n### 注意事项\n1. **区分测试失败类型**：\n   - 编译错误 vs 运行时错误\n   - 断言失败 vs 预期panic\n   - 逻辑错误 vs 环境依赖\n\n2. **测试属性解读**：\n   - `#[should_panic]`：测试应该panic，显示\"should panic ... ok\"表示成功\n   - `#[ignore]`：测试被忽略，不算失败\n   - `#[cfg(test)]`：仅在测试时编译\n\n3. **状态隔离**：\n   - 确保测试之间没有共享状态污染\n   - 使用适当的清理函数重置全局状态\n\n### 可选步骤\n- 添加调试输出到关键函数\n- 使用 `dbg!` 宏跟踪变量状态\n- 检查测试依赖的模块实现\n- 验证测试数据的正确性"
}