{
  "problem_type": "Rust并发测试修复",
  "content": "## 问题重述\nRust测试在多线程环境下因全局状态共享导致PoisonError或数据竞争，表现为：\n- 测试间歇性失败\n- 出现PoisonError错误\n- 共享状态值不符合预期\n\n## 可复用解决流程\n\n### 步骤1：问题诊断\n1. 运行测试确认错误：`cargo test 测试名 -- --nocapture`\n2. 识别共享状态：查找static变量、全局状态\n3. 分析并发访问点：检查哪些函数修改/读取共享状态\n\n### 步骤2：实施修复\n1. **状态保护**：\n   ```rust\n   use std::sync::Mutex;\n   lazy_static::lazy_static! {\n       static ref TEST_LOCK: Mutex<()> = Mutex::new(());\n       static ref SHARED_STATE: Mutex<Type> = Mutex::new(initial_value);\n   }\n   ```\n\n2. **测试隔离**：\n   ```rust\n   #[test]\n   fn test_xxx() {\n       let _lock = TEST_LOCK.lock().unwrap();\n       reset_state(); // 重置共享状态\n       // 测试逻辑\n   }\n   ```\n\n3. **状态清理函数**：\n   ```rust\n   fn reset_state() {\n       let mut state = SHARED_STATE.lock().unwrap();\n       *state = initial_value;\n   }\n   ```\n\n### 步骤3：验证修复\n1. 单独运行每个相关测试确认通过\n2. 批量运行测试：`cargo test pattern_`\n3. 检查无PoisonError或竞争条件\n\n## 注意事项\n- 确保锁在测试生命周期内保持（使用let _lock）\n- panic时锁会自动poison，需处理PoisonError\n- 考虑使用std::sync::atomic对简单类型进行无锁操作\n\n## 可选步骤\n- 使用`cargo test --release`验证优化模式下的并发安全性\n- 添加`RUST_LOG=debug`环境变量获取详细调试信息\n- 考虑使用`std::sync::Once`进行一次性初始化"
}