{
  "problem_type": "Rust全局状态测试修复",
  "content": "## 问题重述\nRust测试中全局状态变量导致的测试间状态污染问题，表现为测试单独运行通过但批量运行失败，或期望值与实际值不符。\n\n## 可复用解决流程\n\n### 阶段1：问题识别\n**工具使用**：\n- `cargo test test_name -- --exact` - 验证单个测试状态\n- `cargo test -- --nocapture | grep -E '(FAILED|test_name)'` - 批量测试状态概览\n\n### 阶段2：根因分析\n**关键步骤**：\n1. 识别全局状态变量（如DEPTH、计数器、缓存等）\n2. 运行`rg -n \\\"变量名\\\" src/`定位所有使用点\n3. 检查测试函数是否包含状态重置机制\n4. 验证测试执行顺序是否影响结果\n\n### 阶段3：修复实施\n**最小改动原则**：\n1. 为全局状态添加`reset_xxx()`函数\n2. 在每个测试函数开始处调用`reset_xxx()`\n3. 保持原有业务逻辑不变\n\n### 阶段4：验证确认\n**验证序列**：\n1. `cargo test 具体测试名 -- --exact` - 确认单个测试通过\n2. `cargo test 模块名::tests:: - 确认模块内所有测试通过\n3. `cargo test` - 确认整体测试套件无回归\n\n## 注意事项\n- 优先使用显式状态重置而非隐式清理\n- 对于复杂状态，考虑使用fixture或setup/teardown模式\n- 状态重置函数应幂等，可多次调用无副作用\n- 修复后检查是否存在其他受影响测试\n\n## 可选步骤\n如需更高级的状态管理：\n- 使用`lazy_static!`+`Mutex`包装全局状态\n- 考虑使用测试fixture库如`rstest`\n- 对于并发测试，使用`std::sync::atomic`操作"
}