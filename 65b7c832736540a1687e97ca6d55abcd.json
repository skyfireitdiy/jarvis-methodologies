{
  "problem_type": "C到Rust字符串比较语义对齐",
  "content": "# C到Rust字符串比较语义对齐方法论\n\n## 问题重述\n在 C 到 Rust 代码移植过程中，字符串比较方式存在语义差异：\n- C 语言常用 `strncmp(str1, str2, len)` 进行指定长度比较\n- Rust 默认使用 `==` 进行完整字符串比较\n- 可能导致行为不一致，特别是处理包含 null 字节或长度限制的场景\n\n## 可复用解决流程\n\n### 步骤1：差异识别\n1. 定位 C 代码中的字符串比较逻辑\n2. 识别比较方式：`strncmp`、`strcmp`、`memcmp` 等\n3. 确认比较的关键特征：长度限制、终止条件、大小写敏感等\n\n### 步骤2：语义映射\n根据 C 实现选择合适的 Rust 实现：\n- `strncmp(a, b, n)` → `a.len() == n && a == &b[..n]`\n- `strcmp(a, b)` → `a == b`\n- `memcmp(a, b, n)` → `a.len() == n && a == &b[..n]`（对于字节比较）\n\n### 步骤3：实现修改\n使用 `edit_file` 工具进行最小修改：\n- 保持函数签名不变\n- 仅修改比较逻辑部分\n- 确保类型匹配（避免 `String` vs `&str` 比较错误）\n\n### 步骤4：验证测试\n1. 运行 `cargo test -- --nocapture`\n2. 检查所有测试用例通过\n3. 验证边界情况（空字符串、长度不匹配、特殊字符）\n4. 确保无回归问题\n\n## 注意事项\n- Rust 的字符串比较自动处理 UTF-8 边界，而 C 的 `strncmp` 按字节比较\n- 对于二进制数据，应使用 `&[u8]` 而非 `&str`\n- 检查是否需要大小写敏感比较（`eq_ignore_ascii_case`）\n\n## 可选步骤\n- 添加针对性测试用例验证边界情况\n- 使用 `cargo clippy` 检查潜在问题\n- 性能测试验证无性能退化"
}