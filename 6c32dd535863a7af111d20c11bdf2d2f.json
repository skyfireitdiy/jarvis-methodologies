{
  "problem_type": "Rust测试失败修复",
  "content": "# Rust测试失败修复方法论\n\n## 问题重述\nRust项目中的单元测试失败，需要定位并修复根本原因，确保所有测试通过且无回归。\n\n## 可复用解决流程\n\n### 步骤1：问题诊断\n1. 收集完整的测试失败信息\n   - 使用 `cargo test -- --nocapture` 获取详细输出\n   - 记录失败的测试用例名称和断言信息\n2. 定位源代码位置\n   - 根据错误信息中的文件路径和行号定位\n   - 使用 `read_code` 工具读取相关代码片段\n\n### 步骤2：根因分析\n1. 分析测试断言失败的原因\n   - 比较期望值与实际值\n   - 检查函数参数和返回值\n2. 验证依赖关系\n   - 确保所有被调函数已实现\n   - 检查数据结构完整性\n3. 对比C实现（如适用）\n   - 使用 `read_symbols` 获取C源码参考\n   - 确认Rust实现与C实现的差异\n\n### 步骤3：修复实施\n1. 最小必要改动\n   - 仅修改导致失败的代码\n   - 保持原有代码风格和结构\n2. 内存安全处理\n   - 使用安全API替代不安全操作\n   - 正确处理裸指针和Box转换\n3. 边界条件处理\n   - 添加wrapping_add/wrapping_sub避免溢出\n   - 处理空值和边界情况\n\n### 步骤4：验证确认\n1. 运行特定测试\n   - `cargo test <test_name>` 快速验证\n2. 运行全部测试\n   - `cargo test` 确保无回归\n3. 清理和优化\n   - 消除编译警告\n   - 移除不必要的unsafe块\n\n## 注意事项\n- 始终先备份原始代码（使用Git）\n- 优先使用标准库API\n- 避免使用todo!/unimplemented!占位符\n- 确保中文注释规范\n- 每次改动后都运行测试验证\n\n## 可选步骤\n- 添加调试输出辅助定位\n- 使用 `RUST_BACKTRACE=1` 获取完整堆栈\n- 运行 `cargo clippy` 检查代码质量"
}