{
  "problem_type": "大型文件重构Spec编写",
  "content": "# 大型文件重构 Spec 编写方法论\n\n## 问题重述\n\n面对项目中存在的大文件（通常 > 2000 行），存在职责混乱、难以维护、测试覆盖率低等问题。需要通过重构拆分为多个小模块，遵循 SDD 流程，先编写详细的 Spec 文档，再进行实现。\n\n## 可复用解决流程\n\n### 阶段 1：代码分析（COLLECT）\n\n**目标**：全面了解现有代码结构和功能分布\n\n**步骤**：\n1. 使用 `read_code` 读取完整代码文件\n2. 统计代码行数、函数数量、类数量\n3. 识别所有公共函数和私有函数\n4. 按功能将函数分组（例如：配置管理、文件操作、网络请求等）\n5. 统计每个功能组的代码行数和占比\n6. 识别功能组之间的依赖关系\n\n**输出**：功能分布表、依赖关系图\n\n### 阶段 2：问题识别（ANALYZE）\n\n**目标**：明确当前代码存在的问题\n\n**检查项**：\n1. 是否违反单一职责原则（一个文件承担多种不相关职责）\n2. 是否存在代码重复\n3. 是否有过大的函数/类\n4. 是否存在循环依赖\n5. 测试覆盖率是否过低\n\n**输出**：问题清单、严重程度评估\n\n### 阶段 3：拆分方案设计（HYPOTHESIZE）\n\n**目标**：设计可行的模块拆分方案\n\n**原则**：\n1. 职责单一：每个模块只负责一个功能域\n2. 高内聚低耦合：相关功能放在一起，减少模块间依赖\n3. 规模控制：每个模块 < 300 行（复杂场景可放宽到 < 500 行）\n4. 向后兼容：如果文件被广泛引用，需设计兼容层\n\n**设计步骤**：\n1. 确定拆分粒度：粗粒度（3-5个模块）vs 细粒度（10+个模块）\n2. 定义每个新模块的职责\n3. 绘制模块依赖关系图，确保无循环依赖\n4. 设计向后兼容方案（如保留原文件作为兼容导出层）\n\n**方案对比**：\n- 粗粒度：优点是实现简单，缺点是模块仍然较大\n- 细粒度：优点是职责清晰，缺点是实现复杂度高\n\n**输出**：模块拆分方案、依赖关系图\n\n### 阶段 4：接口定义（HYPOTHESIZE）\n\n**目标**：为每个新模块定义清晰的接口\n\n**接口定义内容**：\n1. 函数名称和参数\n2. 参数类型和说明\n3. 返回值类型和说明\n4. 函数功能描述\n5. 边界条件\n6. 异常处理\n\n**工具**：使用表格或 Markdown 格式清晰展示接口\n\n### 阶段 5：Spec 文档编写（EXECUTE）\n\n**目标**：编写完整的重构 Spec 文档\n\n**Spec 文档结构**（必填章节）：\n1. 文档信息（版本、日期、状态）\n2. 功能概述（当前状况、重构目标）\n3. 问题分析（架构问题、代码质量问题、约束条件）\n4. 模块拆分设计（总览、职责定义、依赖关系）\n5. 接口定义（每个模块的详细接口）\n6. 输入输出说明（表格形式）\n7. 边界条件（输入验证、并发控制、资源限制）\n8. 异常处理（异常场景和处理方式）\n9. 验收标准（功能验收、代码质量、测试覆盖率）\n10. 实施计划（阶段划分、执行顺序）\n\n**Spec 文档位置**：`.jarvis/spec/{module_name}_spec.md`\n\n### 阶段 6：验收标准定义（HYPOTHESIZE）\n\n**验收标准类型**：\n\n**1. Spec 文档验收**：\n- Spec 文档存在且格式正确\n- 包含所有必需章节\n- 模块拆分方案可行\n- 验收标准清晰可验证\n\n**2. 代码质量验收**：\n- 每个新模块代码行数 < 300 行\n- 遵循单一职责原则\n- 无循环依赖\n- 代码风格符合规范\n\n**3. 功能完整性验收**：\n- 所有原有功能正常工作\n- 公共接口保持不变\n- 向后兼容性验证通过\n\n**4. 测试覆盖率验收**：\n- 每个新模块测试覆盖率 ≥ 80%\n- 所有公共接口有测试用例\n- 覆盖正常、边界、异常情况\n\n**验证方法**：\n- 文档验证：检查 Spec 文档完整性\n- 代码验证：检查代码行数、依赖关系\n- 功能验证：集成测试\n- 覆盖率验证：pytest + coverage\n\n## 注意事项\n\n### 1. 向后兼容性\n- 如果文件被广泛引用，必须保持所有公共接口不变\n- 可以保留原文件作为兼容导出层，重新导出新模块的接口\n- 不要破坏现有导入路径\n\n### 2. 风险控制\n- 高风险项：拆分最复杂或依赖最多的模块\n- 缓解措施：分阶段拆分，先简单后复杂\n- 保留回退方案：使用 Git 分支，确保可随时回退\n\n### 3. 性能考虑\n- 模块拆分可能增加导入时间\n- 使用延迟导入（lazy import）优化性能\n- 避免循环导入导致的性能问题\n\n### 4. 测试策略\n- 遵循 TDD 原则：先写测试，再实现代码\n- 保留原有测试，确保重构不破坏功能\n- 为每个新模块编写完整的单元测试\n- 增加集成测试，验证模块间协作\n\n## 可选步骤\n\n### 性能优化验证\n如果对性能有要求，可以增加：\n1. 使用 `timeit` 测试导入时间\n2. 对比重构前后的函数执行时间\n3. 使用 `memory_profiler` 分析内存占用\n\n### 可维护性验证\n1. 使用 `pylint` 检查圈复杂度\n2. 使用代码重复率检测工具\n3. 检查文档覆盖率（docstring）\n\n## 工具推荐\n\n- 代码分析：`read_code`、`execute_script`（配合 grep/rg）\n- 依赖分析：手动分析 + 绘制依赖图\n- 测试：pytest + coverage\n- 代码质量：pylint, flake8, mypy\n- 性能分析：timeit, memory_profiler\n\n## 成功标准\n\n1. Spec 文档完整、清晰、可执行\n2. 模块拆分方案符合单一职责原则\n3. 所有验收标准可验证\n4. 实施计划合理，风险可控",
  "scope": "global"
}