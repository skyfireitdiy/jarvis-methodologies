{
  "problem_type": "Rust全局状态测试死锁预防",
  "content": "问题重述：\n在Rust项目中测试涉及全局状态（如全局Mutex、静态变量）的功能时，测试用例可能因为死锁而挂起，导致测试无法正常完成。\n\n可复用解决流程：\n\n1. **识别死锁风险**\n   - 使用 `execute_script` 工具运行测试：`timeout 60 cargo test 测试名 -- --nocapture`\n   - 观察是否出现超时（>60s未返回）\n   - 检查测试代码和被测函数是否可能同时获取相同锁\n\n2. **分析锁使用模式**\n   - 使用 `read_code` 工具查看测试代码和被测函数的锁使用\n   - 重点关注：TEST_LOCK、GLOBAL_SCOPE等全局锁的获取顺序\n   - 标记可能存在循环等待的锁组合\n\n3. **重构测试代码**\n   - 最小化锁持有时间：使用独立作用域控制锁生命周期\n   - 避免嵌套锁：不要在持有锁A的同时尝试获取锁B\n   - 考虑替代方案：使用线程局部变量或测试专用的mock对象\n\n4. **验证修复效果**\n   - 重新运行测试，确保能在30秒内完成\n   - 检查无panic、无死锁、无超时\n\n注意事项：\n- 全局状态测试应优先考虑可测试性设计\n- 使用`std::sync::Mutex`时要特别注意poison错误处理\n- 考虑使用`parking_lot`等替代锁库以获得更好的死锁检测\n\n可选步骤：\n- 使用`cargo test -- --test-threads=1`串行执行测试\n- 为每个测试创建独立的测试环境避免状态污染\n- 使用`lazy_static`或`once_cell`管理复杂全局状态"
}