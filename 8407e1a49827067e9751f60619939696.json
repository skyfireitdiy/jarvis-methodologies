{
  "problem_type": "并发测试失败排查",
  "content": "问题重述：\n当运行cargo test时，部分测试在并发执行环境下失败，但单独运行时通过，通常是由于共享状态竞争导致的。\n\n可复用解决流程：\n1. **验证并发问题**\n   - 执行：`cargo test -- --nocapture` 观察失败模式\n   - 执行：`RUST_TEST_THREADS=1 cargo test -- --nocapture` 验证单线程通过\n   - 如果单线程通过，确认为并发问题\n\n2. **定位共享状态**\n   - 检查测试代码中使用的所有`static`变量\n   - 重点查看`Lazy`、`Mutex`、`Atomic*`相关状态\n   - 使用`println!`或`dbg!`在测试前后输出状态值\n\n3. **修复策略选择**\n   - **方案A（推荐）**：测试隔离 - 使用`RUST_TEST_THREADS=1`强制单线程\n   - **方案B**：状态重置 - 在每个测试的`setup`/`teardown`中重置共享状态\n   - **方案C**：无锁化 - 使用`Atomic*`类型确保原子操作\n   - **方案D**：锁保护 - 对共享状态加锁（性能影响较大）\n\n4. **边界值处理**\n   - 对整数运算使用`.wrapping_add()`/`.wrapping_sub()`避免panic\n   - 使用`usize::MAX`等常量明确边界预期\n   - 添加边界测试验证极端情况\n\n注意事项：\n- 并发测试问题通常是假阳性，实际代码可能正确\n- 优先使用测试隔离而非重构代码，避免过度设计\n- 在CI/CD环境中设置`RUST_TEST_THREADS=1`确保一致性\n- 文档化并发限制，避免后续踩坑\n\n可选步骤：\n- 使用`loom`等并发测试工具进一步验证\n- 添加`proptest`生成随机并发场景测试"
}