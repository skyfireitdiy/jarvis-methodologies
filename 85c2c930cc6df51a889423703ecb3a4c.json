{
  "problem_type": "Rust测试修复后回归验证",
  "content": "# Rust项目测试修复后回归验证方法论\n\n## 问题重述\n修复Rust项目中的编译错误后，如何确保修复不会引入新的回归问题。\n\n## 可复用解决流程\n1. **修复前状态确认**\n   - 记录原始错误/警告信息\n   - 保存当前测试失败情况（如有）\n\n2. **执行修复**\n   - 按最小改动原则修复问题\n   - 保持代码风格一致性\n\n3. **验证修复效果**\n   - 执行 `cargo test -- --nocapture` 获取完整输出\n   - 检查三个关键指标：\n     * 命令返回码必须为0\n     * 编译阶段无错误或警告\n     * 所有现有测试必须通过\n\n4. **问题处理**\n   - 如测试失败，区分是：\n     * 修复引入的回归问题\n     * 现有但未发现的间歇性问题\n   - 对回归问题进行针对性修复\n\n5. **最终确认**\n   - 重新执行完整测试验证\n   - 确认所有指标达标\n\n## 注意事项\n- 特别关注涉及全局状态的测试（临时文件、静态变量等）\n- 使用--nocapture获取详细调试信息\n- 测试失败不一定是修复引入的问题，但任何回归都需处理\n\n## 可选步骤\n- 执行 `cargo clippy` 检查代码质量\n- 运行特定模块的测试以缩小范围"
}