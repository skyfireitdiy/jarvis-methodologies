{
  "problem_type": "C2Rust字符串处理函数转译",
  "content": "## C2Rust字符串处理函数转译方法论\n\n### 问题重述\n将C语言中的字符串处理函数（如字面量合并、解析、格式化等）安全地转译为Rust实现，保持行为一致性。\n\n### 可复用解决流程\n\n#### 第一步：需求分析\n1. **识别C函数签名**：分析原函数参数、返回值、副作用\n2. **确定数据类型映射**：\n   - `char*` → `Vec<u8>` 或 `String`\n   - 枚举类型 → Rust枚举\n   - 结构体 → Rust结构体\n\n#### 第二步：类型设计\n1. **字符串分类枚举**：\n   ```rust\n   #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n   pub enum StringKind {\n       StrNone,    // 普通字符串\n       StrUtf16,   // UTF-16 (L\"...\")\n       StrUtf32,   // UTF-32 (U\"...\")\n   }\n   ```\n\n2. **辅助函数设计**：\n   - `get_string_kind()` - 根据字面量前缀判断类型\n   - `tokenize_string_literal()` - 解析字符串内容\n\n#### 第三步：安全重构\n1. **内存管理**：用Rust所有权系统替代C的malloc/free\n2. **错误处理**：用Result或panic替代C的错误码\n3. **链表处理**：用`Option<Box<T>>`替代裸指针\n\n#### 第四步：TDD实施\n1. **测试用例矩阵**：\n   - 空输入边界测试\n   - 单元素测试\n   - 正常功能测试\n   - 错误路径测试\n   - 类型边界测试\n\n2. **测试工具函数**：\n   - `create_test_token()` - 创建测试token\n   - `create_token_chain()` - 构建测试链表\n   - `assert_tokens_equal()` - 验证结果\n\n#### 第五步：集成验证\n1. 编译验证：`cargo check`\n2. 测试验证：`cargo test`\n3. 行为验证：与C实现对比关键场景\n\n### 注意事项\n1. **字节vs字符**：C使用字节数组，Rust需明确字节/字符边界\n2. **转义处理**：C和Rust字符串转义规则可能不同\n3. **UTF编码**：正确处理不同编码的字面量前缀\n4. **空指针**：用`Option`替代null检查\n\n### 可选优化\n1. **性能优化**：使用`String`替代`Vec<u8>`减少转换\n2. **错误细化**：使用自定义Error类型\n3. **内存优化**：预分配容量减少重新分配"
}