{
  "problem_type": "C到Rust函数TDD移植",
  "content": "# C到Rust函数TDD移植方法论\n\n## 问题重述\n将C源码中的函数移植到Rust，需保持语义等价，使用TDD方法确保正确性。\n\n## 可复用解决流程\n\n### 1. 前期分析阶段\n- **源码获取**: 使用`read_code`获取完整C源码和依赖关系\n- **依赖识别**: 分析函数调用的所有符号，识别未实现依赖\n- **签名映射**: 将C类型映射到Rust原生类型（如`lfs_block_t[2]` → `&[u32; 2]`）\n\n### 2. TDD实施阶段\n```bash\n# 1. Red - 先写测试\ncargo test --lib -- 测试函数名\n\n# 2. Green - 实现最小功能\n# 3. 迭代完善\n```\n\n### 3. 测试设计模板\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_基本功能() { /* 主要功能路径 */ }\n   \n    #[test]\n    fn test_边界情况() { /* 空输入、极值、边界值 */ }\n   \n    #[test]\n    fn test_错误处理() { /* 错误返回码、异常场景 */ }\n   \n    #[test]\n    fn test_与C行为一致性() { /* 验证结果与C实现一致 */ }\n}\n```\n\n### 4. 实现步骤\n1. **添加函数签名**（返回NotImplemented）\n2. **添加测试用例**（使测试编译通过）\n3. **逐步实现**（每个依赖函数单独实现）\n4. **验证测试**（确保所有测试通过）\n\n### 5. 注意事项\n- **保持语义等价**：返回值、错误码必须与C一致\n- **类型安全**：使用Rust类型系统而非C风格类型\n- **依赖处理**：先实现底层依赖，再实现上层逻辑\n- **边界测试**：必须覆盖空指针、空数组、极值等边界情况\n- **文档注释**：使用中文注释，说明与C函数的对应关系\n\n### 6. 可扩展工具使用\n- 使用`read_symbols`获取符号依赖图\n- 使用`execute_script`运行cargo test验证\n- 使用`edit_file`进行增量修改"
}