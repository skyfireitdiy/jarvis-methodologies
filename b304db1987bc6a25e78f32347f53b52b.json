{
  "problem_type": "Rust枚举错误变体设计",
  "content": "## 问题重述\n在Rust项目中需要为错误处理枚举添加新的变体，特别是需要携带上下文信息的错误类型。\n\n## 可复用解决流程\n\n### 步骤1：分析错误变体需求\n- 确定错误是否需要携带上下文信息（如位置、名称、相关值）\n- 评估是否需要额外的调试信息\n- 检查是否需要支持部分匹配或解构\n\n### 步骤2：选择合适的枚举变体类型\n- **单元变体**：适用于不需要额外信息的简单错误\n  ```rust\n  enum Error { SimpleError }\n  ```\n- **元组变体**：适用于需要少量固定信息的错误\n  ```rust\n  enum Error { TupleError(String, usize) }\n  ```\n- **结构体变体**：适用于需要多个字段或需要命名的信息\n  ```rust\n  enum Error {\n      StructError {\n          message: String,\n          span: Span,\n          suggestion: Option<String>,\n  }\n  }\n  ```\n\n### 步骤3：实现Display trait\n- 为新变体添加对应的匹配分支\n- 确保错误消息清晰且对用户友好\n- 包含所有必要的上下文信息\n\n### 步骤4：更新使用代码\n- 搜索现有代码中可能使用该错误变体的地方\n- 更新构造站点以提供必要字段\n- 更新解构站点以处理新结构\n\n### 步骤5：验证和测试\n- 使用`cargo check`确保编译通过\n- 使用`cargo test`运行相关测试\n- 验证错误消息的格式和内容\n\n## 注意事项\n1. 优先使用结构体变体而非元组变体，提高代码可读性\n2. 确保所有字段都实现必要的trait（Clone, Copy, Debug等）\n3. 考虑错误类型的向后兼容性\n4. 对于跨模块使用的错误，确保字段类型是公开的\n\n## 可选步骤\n- 为复杂错误类型实现`From` trait以简化错误转换\n- 添加错误链接机制（Error::source）\n- 实现`PartialEq`等trait以支持测试断言"
}